# Copyright 2017 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import json
import logging
import re
from urlparse import urlparse

from gae_libs.http.http_client_appengine import HttpClientAppengine
from infra_api_clients.codereview import codereview
from infra_api_clients.codereview import cl_info
from libs import time_util


class Gerrit(codereview.CodeReview):  # pragma: no cover
  """Stub for implementing Gerrit support."""
  HTTP_CLIENT = HttpClientAppengine(follow_redirects=False)

  def __init__(self, host, settings=None):
    super(Gerrit, self).__init__(host)
    settings = settings or {}
    self.commit_bot_emails = settings.get('commit_bot_emails',
                                          ['commit-bot@chromium.org'])

  def _Get(self, path_parts, params=None, headers=None):
    """Makes a simple get to Gerrit's API and parses the json output."""
    # Prepend /a/ to make the request authenticated.
    path_parts = ['a'] + list(path_parts)
    url = 'https://%s/%s' % (self._server_hostname, '/'.join(path_parts))
    # This header tells gerrit to send compact (non-pretty) JSON which is
    # more efficient and encouraged for automated tools.
    headers = headers or {}
    headers['Accept'] = 'application/json'
    status_code, content = self.HTTP_CLIENT.Get(url, params=params,
                                                headers=headers)
    if status_code != 200:
      return None
    # Remove XSSI magic prefix.
    if content.startswith(')]}\''):
      content = content[4:]
    return json.loads(content)

  def GetCodeReviewUrl(self, change_id):
    return 'https://%s/q/%s' % (self._server_hostname, change_id)

  # TODO(crbug.com/702681): flesh out these methods.
  def PostMessage(self, change_id, message):
    raise NotImplementedError()

  def CreateRevert(self, reason, change_id, patchset_id=None):
    raise NotImplementedError()

  def AddReviewers(self, change_id, reviewers, message=None):
    raise NotImplementedError()

  def GetClDetails(self, change_id):
    # Create cl info based on the url.
    params = {'o': ['CURRENT_REVISION', 'CURRENT_COMMIT']}
    change_info = self._Get(['changes', change_id, 'detail'], params=params)
    return self._ParseClInfo(change_info, change_id)

  def _ParseClInfo(self, change_info, change_id):
    if not change_info:
      return None

    result = cl_info.ClInfo(self._server_hostname, change_id)

    result.reviewers = [x['email'] for x in change_info['reviewers'].get(
      'REVIEWER', [])]
    result.cc = [x['email'] for x in change_info['reviewers'].get('CC', [])]
    result.closed = change_info['status'] == 'MERGED'

    # If the status is merged, look at the commit details for the current
    # commit.
    if result.closed:
      current_revision = change_info['current_revision']
      revision_info = change_info['revisions'][current_revision]
      patchset_id = revision_info['_number']
      commit_timestamp = time_util.DatetimeFromString(
          change_info['submitted'])
      result.commits.append(cl_info.Commit(patchset_id, current_revision,
                                           commit_timestamp))
      # Detect manual commits.
      committer = revision_info['commit']['committer']['email']
      if committer not in self.commit_bot_emails:
        result.AddCqAttempt(patchset_id, committer, commit_timestamp)

    # TO FIND COMMIT ATTEMPTS:
    # In messages look for "Patch Set 1: Commit-Queue+2"
    # or "Patch Set 4: Code-Review+1 Commit-Queue+2".
    cq_pattern = re.compile('^Patch Set \d+:( Code-Review..)? Commit-Queue\+2$')
    revert_tag = 'autogenerated:gerrit:revert'
    revert_pattern = re.compile(
        'Created a revert of this change as (?P<change_id>I[a-f\d]{40})')

    for message in change_info['messages']:
      if cq_pattern.match(message['message'].splitlines()[0]):
        patchset_id = message['_revision_number']
        author = message['author']['email']
        timestamp = time_util.DatetimeFromString(message['date'])
        result.AddCqAttempt(patchset_id, author, timestamp)

      # TO FIND REVERT(S):
      if message.get('tag') == revert_tag:
        patchset_id = message['_revision_number']
        author = message['author']['email']
        timestamp = time_util.DatetimeFromString(message['date'])
        reverting_change_id = revert_pattern.match(
          message['message']).group('change_id')
        reverting_cl = self.GetClDetails(reverting_change_id)
        result.reverts.append(cl_info.Revert(patchset_id, reverting_cl, author,
                                             timestamp))
    return result
