<link rel="import" href="../../bower_components/polymer-redux/polymer-redux.html">
<script src="../../node_modules/redux/dist/redux.js"></script>
<script>
  (function(window) {
    // Assumption: We don't want to display multiple dialogs at once.
    const DialogState = Object.freeze({
      NONE: 0,
      EDIT_ISSUE: 1,

      // TODO(zhangtiff): Move other dialogs to be managed by Redux. (or not?)
      EDIT_APPROVAL: 2,
      VIEW_ATTACHMENT: 3,
    });

    const actionType = {
      // Misc global state.
      UPDATE_ISSUE_REF: 'UPDATE_ISSUE_REF',
      UPDATE_USER: 'UPDATE_USER',

      // UI state.
      OPEN_DIALOG: 'OPEN_DIALOG',
      CLOSE_DIALOG: 'CLOSE_DIALOG',

      // AJAX request state.
      FETCH_PROJECT_CONFIG_START: 'FETCH_PROJECT_CONFIG_START',
      FETCH_PROJECT_CONFIG_SUCCESS: 'FETCH_PROJECT_CONFIG_SUCCESS',
      FETCH_PROJECT_CONFIG_FAILURE: 'FETCH_PROJECT_CONFIG_FAILURE',

      FETCH_ISSUE_START: 'FETCH_ISSUE_START',
      FETCH_ISSUE_SUCCESS: 'FETCH_ISSUE_SUCCESS',
      FETCH_ISSUE_FAILURE: 'FETCH_ISSUE_FAILURE',

      STAR_ISSUE_START: 'STAR_ISSUE_START',
      STAR_ISSUE_SUCCESS: 'STAR_ISSUE_SUCCESS',
      STAR_ISSUE_FAILURE: 'STAR_ISSUE_FAILURE',

      FETCH_IS_STARRED_START: 'FETCH_IS_STARRED_START',
      FETCH_IS_STARRED_SUCCESS: 'FETCH_IS_STARRED_SUCCESS',
      FETCH_IS_STARRED_FAILURE: 'FETCH_IS_STARRED_FAILURE',

      FETCH_COMMENTS_START: 'FETCH_COMMENTS_START',
      FETCH_COMMENTS_SUCCESS: 'FETCH_COMMENTS_SUCCESS',
      FETCH_COMMENTS_FAILURE: 'FETCH_COMMENTS_FAILURE',

      FETCH_REFERENCES_START: 'FETCH_REFERENCES_START',
      FETCH_REFERENCES_SUCCESS: 'FETCH_REFERENCES_SUCCESS',
      FETCH_REFERENCES_FAILURE: 'FETCH_REFERENCES_FAILURE',

      UPDATE_ISSUE_START: 'UPDATE_ISSUE_START',
      UPDATE_ISSUE_SUCCESS: 'UPDATE_ISSUE_SUCCESS',
      UPDATE_ISSUE_FAILURE: 'UPDATE_ISSUE_FAILURE',

      UPDATE_APPROVAL_START: 'UPDATE_APPROVAL_START',
      UPDATE_APPROVAL_SUCCESS: 'UPDATE_APPROVAL_SUCCESS',
      UPDATE_APPROVAL_FAILURE: 'UPDATE_APPROVAL_FAILURE',
    };

    const actionCreator = {
      fetchReferences: (dispatch, comments) => {
        dispatch({type: actionType.FETCH_REFERENCES_START});

        window.__autolink.getReferencedArtifacts(comments).then((refs) => {
          commentRefs = new Map();
          refs.forEach(({componentName, existingRefs}) => {
            commentRefs.set(componentName, existingRefs);
          });
          dispatch({
            type: actionType.FETCH_REFERENCES_SUCCESS,
            commentReferences: commentRefs,
          });
        }, (error) => {
          dispatch({
            type: actionType.FETCH_REFERENCES_FAILURE,
            error,
          });
        });
      },
      fetchIssue: (dispatch, message) => {
        dispatch({type: actionType.FETCH_ISSUE_START});

        const getIssue = window.prpcClient.call(
          'monorail.Issues', 'GetIssue', message
        );

        getIssue.then((resp) => {
          dispatch({
            type: actionType.FETCH_ISSUE_SUCCESS,
            issue: resp.issue,
          });
        }, (error) => {
          dispatch({
            type: actionType.FETCH_ISSUE_FAILURE,
            error,
          });
        });
      },
      fetchComments: (dispatch, message) => {
        dispatch({type: actionType.FETCH_COMMENTS_START});

        const getComments = window.prpcClient.call(
          'monorail.Issues', 'ListComments', message
        );

        getComments.then((resp) => {
          dispatch({
            type: actionType.FETCH_COMMENTS_SUCCESS,
            comments: resp.comments,
          });
            actionCreator.fetchReferences(dispatch, resp.comments);
        }, (error) => {
          dispatch({
            type: actionType.FETCH_COMMENTS_FAILURE,
            error,
          });
        });
      },
      fetchIsStarred: (dispatch, message) => {
        dispatch({type: actionType.FETCH_IS_STARRED_START});

        const getIsStarred = window.prpcClient.call(
          'monorail.Issues', 'IsIssueStarred', message
        );

        getIsStarred.then((resp) => {
          dispatch({
            type: actionType.FETCH_IS_STARRED_SUCCESS,
            isStarred: resp.isStarred,
          });
        }, (error) => {
          dispatch({
            type: actionType.FETCH_IS_STARRED_FAILURE,
            error,
          });
        });
      },
      updateIssue: (dispatch, message) => {
        dispatch({type: actionType.UPDATE_ISSUE_START});

        window.prpcClient.call(
          'monorail.Issues', 'UpdateIssue', message
        ).then((resp) => {
          dispatch({
            type: actionType.UPDATE_ISSUE_SUCCESS,
            issue: resp.issue,
          });
          const fetchCommentsMessage = {
            issueRef: message.issueRef,
          };
          actionCreator.fetchComments(dispatch, fetchCommentsMessage);
        }, (error) => {
          dispatch({
            type: actionType.UPDATE_ISSUE_FAILURE,
            error: error,
          });
        });
      },
    };

    const initial = {
      issueId: 0,
      projectName: '',
      projectConfig: {},
      issue: {},
      comments: [],
      commentReferences: new Map(),
      isStarred: false,

      openedDialog: DialogState.NONE,

      issueLoaded: false,
      fetchingIssue: false,
      fetchIssueError: null,

      fetchingProjectConfig: false,
      fetchProjectConfigError: null,

      fetchingComments: false,
      fetchCommentsError: null,

      fetchingReferences: false,
      fetchingReferencesError: null,

      starringIssue: false,
      starIssueError: null,

      fetchingIsStarred: false,
      fetchIsStarredError: null,

      updatingIssue: false,
      updateIssueError: null,

      // Assumption: It's okay to prevent the user from sending multiple
      // approval update requests at once, even for different approvals.
      updatingApproval: false,
      updateApprovalError: null,
    };

    // Helpers for the reducers.
    const updateIssueApproval = (issue, approval) => {
      if (!issue.approvalValues) return issue;
      const newApprovals = issue.approvalValues.map((item, i) => {
        if (item.fieldRef.fieldName === approval.fieldRef.fieldName) {
          // PhaseRef isn't populated on the response so we want to make sure
          // it doesn't overwrite the original phaseRef with {}.
          const a = Object.assign({}, approval, {phaseRef: item.phaseRef});
          return a;
        }
        return item;
      });
      return Object.assign({}, issue, {approvalValues: newApprovals});
    }

    const reducer = (state, action) => {
      switch (action.type) {
        case actionType.UPDATE_ISSUE_REF:
          return Object.assign({}, state, {
            issueId: action.issueId || state.issueId,
            projectName: action.projectName || state.projectName,
          });
        case actionType.UPDATE_USER:
          return Object.assign({}, state, {
            user: action.user,
          });

        // Opening and closing dialogs.
        case actionType.OPEN_DIALOG:
          return Object.assign({}, state, {
            openedDialog: action.dialog,
          });
        case actionType.CLOSE_DIALOG:
          return Object.assign({}, state, {
            openedDialog: DialogState.NONE,
          });

        // Request for getting configuration settings for a project.
        case actionType.FETCH_PROJECT_CONFIG_START:
          return Object.assign({}, state, {
            fetchProjectConfigError: null,
            fetchingProjectConfig: true,
          });
        case actionType.FETCH_PROJECT_CONFIG_SUCCESS:
          return Object.assign({}, state, {
            projectConfig: action.projectConfig,
            fetchingProjectConfig: false,
          });
        case actionType.FETCH_PROJECT_CONFIG_FAILURE:
          return Object.assign({}, state, {
            fetchProjectConfigError: action.error,
            fetchingProjectConfig: false,
          });

        // Request for getting an issue.
        case actionType.FETCH_ISSUE_START:
          return Object.assign({}, state, {
            fetchIssueError: null,
            fetchingIssue: true,
          });
        case actionType.FETCH_ISSUE_SUCCESS:
          return Object.assign({}, state, {
            issue: action.issue,
            issueLoaded: true,
            fetchingIssue: false,
          });
        case actionType.FETCH_ISSUE_FAILURE:
          return Object.assign({}, state, {
            fetchIssueError: action.error,
            fetchingIssue: false,
          });

        // Request for starring an issue.
        case actionType.STAR_ISSUE_START:
          return Object.assign({}, state, {
            starIssueError: null,
            starringIssue: true,
          });
        case actionType.STAR_ISSUE_SUCCESS:
          return Object.assign({}, state, {
            issue: Object.assign({}, state.issue, {starCount: action.starCount}),
            isStarred: action.isStarred,
            starringIssue: false,
          });
        case actionType.STAR_ISSUE_FAILURE:
          return Object.assign({}, state, {
            starIssueError: action.error,
            starringIssue: false,
          });

        // Request for getting comments for an issue.
        case actionType.FETCH_COMMENTS_START:
          return Object.assign({}, state, {
            commentReferences: new Map(),
            fetchCommentsError: null,
            fetchingComments: true,
          });
        case actionType.FETCH_COMMENTS_SUCCESS:
          return Object.assign({}, state, {
            comments: action.comments,
            fetchingComments: false,
          });
        case actionType.FETCH_COMMENTS_FAILURE:
          return Object.assign({}, state, {
            fetchCommentsError: action.error,
            fetchingComments: false,
          });

         // Request for getting comments for an issue.
        case actionType.FETCH_REFERENCES_START:
          return Object.assign({}, state, {
            fetchReferencesError: null,
            fetchingReferences: true,
          });
        case actionType.FETCH_REFERENCES_SUCCESS:
          return Object.assign({}, state, {
            commentReferences: action.commentReferences,
            fetchingReferences: false,
          });
        case actionType.FETCH_REFERENCES_FAILURE:
          return Object.assign({}, state, {
            fetchReferencesError: action.error,
            fetchingReferences: false,
          });

        // Request for getting whether an issue is starred.
        case actionType.FETCH_IS_STARRED_START:
          return Object.assign({}, state, {
            fetchIsStarredError: null,
            fetchingIsStarred: true,
          });
        case actionType.FETCH_IS_STARRED_SUCCESS:
          return Object.assign({}, state, {
            isStarred: action.isStarred,
            fetchingIsStarred: false,
          });
        case actionType.FETCH_IS_STARRED_FAILURE:
          return Object.assign({}, state, {
            fetchIsStarredError: action.error,
            fetchingIsStarred: false,
          });

        // Request for updating an issue.
        case actionType.UPDATE_ISSUE_START:
          return Object.assign({}, state, {
            updatingIssue: true,
          });
        case actionType.UPDATE_ISSUE_SUCCESS:
          return Object.assign({}, state, {
            issue: action.issue,
            updatingIssue: false,
          });
        case actionType.UPDATE_ISSUE_FAILURE:
          return Object.assign({}, state, {
            updateIssueError: action.error,
            updatingIssue: false,
          });

        // Request for updating an approval.
        case actionType.UPDATE_APPROVAL_START:
          return Object.assign({}, state, {
            updatingApproval: true,
          });
        case actionType.UPDATE_APPROVAL_SUCCESS:
          return Object.assign({}, state, {
            issue: updateIssueApproval(state.issue, action.approval),
            updatingApproval: false,
          });
        case actionType.UPDATE_APPROVAL_FAILURE:
          return Object.assign({}, state, {
            updateApprovalError: action.error,
            updatingApproval: false,
          });

        default:
          return state;
      }
    };
    const store = Redux.createStore(reducer, initial);

    ReduxMixin = PolymerRedux(store);

    window.ReduxMixin = ReduxMixin || {};
    window.store = store || {};
    window.actionType = actionType || {};
    window.actionCreator = actionCreator || {};
    window.DialogState = DialogState || {};
  })(window);
</script>
