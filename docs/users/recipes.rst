Recipes user guide
==================

:Author: nodir@
:Last updated: 2015-03-04

Recipes is tool for Python to write build scripts, where build steps and tests
are first-class citizens. A build step is a single command execution with a
name, log(s) and output(s). Recipes is the primary scripting tool for "builds"
used by chrome-infra. It is independent from Buildbot.

Hello world
-----------

This example runs a single build step, ``echo hello world``.

.. code-block:: python

  # Import 'step' recipe module.
  DEPS = [
    'step',  # Runs shell commands.
  ]

  def GenSteps(api):
    # Emit a step.
    api.step(
        'say hi',  # Name of the step
        ['echo', 'hello world'],  # A shell command to run.
    )

  def GenTests(api):
    # Run GenSteps with default input
    yield api.test('basic')

A few things to note:

- the ``DEPS`` special variable specifies the list of recipe modules to import
    - recipe modules are like Python modules, except they can be imported by a
      recipe, generate build steps and provide api for testing/mocking.
- ``GenSteps`` top-level function generates a list of build steps by calling
  ``api.step`` or functions in other recipe modules. The ``step`` module canemit
  a build step that runs a shell command.
    - The ``api`` parameter provides access to imported modules, for instance
      ``api.step``, ``api.git.checkout``, etc.
    - The ``step`` recipe module is specifically defined to act like a function.
      Many other recipe modules do not do that, but just provide functions,
      e.g. ``api.module1.func1()``.
- Testing recipes is based on expectations, where a recipe is executed with a
  given set of inputs.  The resulting commands are not executed directly, but
  compared to an expected list of commands stored in the repository. This
  allows to easily see how a given change in the recipe code affects the
  executed commands and allows these changes to be reviewed. ``GenTests``
  generates test cases by yielding ``api.test()``. The test engine checks that
  for each test case the steps generated by GenSteps match the expected list of
  steps. In this example only one test is defined and no input is specified.
    - The ``api`` parameter is different from api in ``GenSteps``, it provides
      access to imported modules' test api.
    - Unlike ``GenSteps``, for historical reasons, ``GenTests`` must return an
      iterable.

Save this file to ``build/scripts/slave/recipes/yourproject.py`` or
``build_internal/scripts/slave/recipes/yourproject.py`` if your project is
internal.

Running a recipe locally
------------------------

Use ``run_recipe.py`` to run a recipe locally::

  build/scripts/tools/run_recipe.py <recipe-name>

Here <recipe-name> is a the name of the recipe file without an extension.

Simulation, expectations and tests
----------------------------------

Recipes can be executed in simulation mode. In this mode, steps are not actually
executed, but return faked results/output.

Simulation mode is used to generate the list of expected steps. For each test
case emitted from ``GenTests`` there is a json file that describes the expected
list of steps to run. Expectation files are intended to be checked into the
repo. A test run ensures that generated steps match the expected ones and that
100% of recipe code is covered by tests. Initially or whenever you intend to
change steps you will need to (re)generate expectation files.

Generating expectation files
****************************

To generate expectation files run::

  build/scripts/slave/unittests/recipe_simulation_test.py train <recipe-name>

This will generate expectation files in <recipe-name>.expectations/ sibling
directory. This generates expectations only for your recipe (there are other
recipes in the repo). Review them to make sure your recipes do what you
indented to do.

Running tests
*************

To run tests for a given recipe::

  build/scripts/slave/unittests/recipe_simulation_test.py test <recipe-name>

This runs tests only for your recipe, but without coverage. To see coverage,
run tests for all recipes::

  build/scripts/slave/unittests/recipe_simulation_test.py test

100% recipe coverage is required by chrome-infra repositories.

Mocking step results in tests
*****************************

In GenTests, a test case produced by api.test can be enhanced with mocked step
results::

  # Expect step to fail
  yield (
      api.test('failed') +
      api.step_data('step_name', retcode=1))

The plus sign is used to modify a test case. step_data can also accept fake
output data, see Placeholders_ below.

Recipe parameters (build properties)
------------------------------------

Build properties are input/output parameters for a recipe. For example, on
buildbot, the "buildername" property specifies the configuration to run.

Example:

.. code-block:: python

  # recipes/helloworld.py
  DEPS = [
      ...
      'properties'
  ]

  def GenSteps(api):
    builder_name = api.properties.get('buildername')
    if builder_name == 'myawesomebuilder':
      # Run an awesome step

  def GenTests(api):
    yield api.test('basic')
    yield (
        api.test('awesome') +
        api.properties(buildername='myawesomebuilder'),
    )

In this example the recipe runs an extra step if ``buildername`` property is
``'myawesomebuilder'``. The plus sign after ``api.test('awesome')`` means "add
the following test data", where the test data is values of build properties.

Running locally with property values
************************************

When running a recipe locally, you can specify build properties as
``name=value`` arguments. Values are attempted to be parsed as JSON value, so
numbers, dicts, lists are supported.

Example::

  build/scripts/tools/run_recipe.py helloworld  \
      buildername=awesomebuilder

Step presentation
-----------------

A recipe can add extra info to step presentation after the step has executed.
The ``step`` function and many other recipe modules return a step result.
Step result's ``presentation`` attribute is where you specify new output.

Example: logging
******************

.. code-block:: python

  step_result = api.step(...)
  step_result.presentation.logs['mylog'] = ['line1', 'line2']

Note: a log is a list of log lines

Example: set properties
***********************

``api.properties`` are immutable, but you can change and add new properties at
the buildbot level.

.. code-block:: python

  step_result = api.step(...)
  step_result.presentation.properties['newprop'] = 1

Example: step text
******************

This modifies the text displayed next to a step name::

  step_result = api.step(...)
  step_result.presentation.step_text = 'Dynamic step result text'

Placeholders
------------

A placeholder is a data source/destination that you can pass as step
input/output, as well as step test data. Two main modules that have implemented
placeholders are raw_io and json.

Example: read standard output of a step
***************************************

.. code-block:: python

  step_result = api.step(..., stdout=api.raw_io.output())
  data = step_result.stdout

Also see `raw_io's example.py`_.

Example: write to standard input of a step
******************************************

.. code-block:: python

  api.step(..., stdin=api.raw_io.input('test input'))

Also see `raw_io's example.py`_.

Example: read standard output of a step as json
***********************************************

.. code-block:: python

  step_result = api.step(..., stdout=api.json.output())
  data = step_result.stdout
  # data is a parsed JSON value, such as dict

Also see `json's example.py`_.

Example: write to standard input of a step as json
**************************************************

.. code-block:: python

  data = {'value': 1}
  api.step(..., stdin=api.json.input(data))

Also see `json's example.py`_.

Example: simulated step output
*********************************

This example specifies the standard output that should be returned when a step
is executed in simulation mode. This is typically used for specifying default
test data in the recipe or recipe module and removes the need to specify too
much test data for each test in GenTests::

  api.step(..., step_test_data=api.raw_io.output('test data'))

Example: simulated step output for a test case
**********************************************

.. code-block:: python

  yield (
      api.test('my_test') +
      api.step_data(
          'step_name',
          output=api.raw_io.output('test data')))

Writing a recipe module
-----------------------

Writing a recipe module is a lot of like writing a recipe, except

- A recipe module cannot be run directly
- A recipe module can import a python module, but should use other modules
  where possible
- A recipe module is a directory with files api.py (required), test_api.py, etc

Directory structure
*******************

A recipe module directory may have the following files:

- __init__.py: required, specifies imported recipe modules in ``DEPS`` variable.
- api.py: required, defines recipe module class with exported methods
- example.py: serves two purposes
   - Example of usage
   - Code coverage for the module
- test_api.py: defines "test api", functions needed for mocking step
  input/output required/provided by this module
- resources/: subdirectory, may contain resource files, for instance a python
  script executed as a step.

Hello world recipe module
*************************

This example defines a helloworld module::

    # recipe_modules/helloworld/__init__.py
    DEPS = [
      'step',
    ]

.. code-block:: python

    # recipe_modules/helloworld/api.py
    from slave import recipe_api

    class HelloWorldApi(recipe_api.RecipeApi):
      def hello(self):
        self.m.step('hello', ['echo', 'Hello', 'World!'])

.. code-block:: python

    # recipe_modules/helloworld/example.py
    DEPS = [
      'helloworld', # the module has to be imported explicitly
    ]
    def GenSteps(api):
      api.helloworld.hello()
    def GenTests(api):
      yield api.test('basic')


A few things to note:

- Imported modules are accessible through ``self.m.<module-name>``.
- Recipe class names have an "Api" suffix as a convention

Resources
#########

A resource is a file stored in the resources/ sub-directory and accessible for
the module. Use ``self.resource`` to get an absolute path to the resource file.

Example::

    # recipe_modules/helloworld/__init__.py
    DEPS = [
      'python',
      'step',
    ]

.. code-block:: python

    # recipe_modules/helloworld/resources/helloworld.py
    print 'Hello World using Python!'

.. code-block:: python

    # recipe_modules/helloworld/api.py
    from slave import recipe_api

    class HelloWorldApi(recipe_api.RecipeApi):
      def hello(self):
        self.m.python('hello', self.resource('helloworld.py'))

.. _raw_io's example.py: https://chromium.googlesource.com/chromium/tools/build.git/+/master/scripts/slave/recipe_modules/raw_io/example.py
.. _json's example.py: https://chromium.googlesource.com/chromium/tools/build.git/+/master/scripts/slave/recipe_modules/json/example.py
