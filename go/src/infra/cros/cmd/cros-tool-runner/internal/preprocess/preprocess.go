// Copyright 2023 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Package preprocess to interface with pre-process.
package preprocess

import (
	"context"
	"log"
	"os"
	"path"
	"path/filepath"

	"github.com/golang/protobuf/jsonpb"

	build_api "go.chromium.org/chromiumos/config/go/build/api"
	"go.chromium.org/chromiumos/config/go/test/api"
	"go.chromium.org/luci/common/errors"

	"infra/cros/cmd/cros-tool-runner/internal/common"
	"infra/cros/cmd/cros-tool-runner/internal/services"
)

const PreProcessName = "pre-process"

// Run pre-process.
func Run(ctx context.Context, req *api.CrosToolRunnerPreTestRequest, preProcessContainer *build_api.ContainerImageInfo, tokenFile string) (res *api.CrosToolRunnerPreTestResponse, err error) {
	// Use host network for dev environment which DUT address is in the form localhost:<port>
	const (
		networkName = "host"
	)

	artifactDir, err := filepath.Abs(req.ArtifactDir)
	if err != nil {
		return nil, errors.Annotate(err, "prepare to run preprocess: failed to resolve artifact directory %v", req.ArtifactDir).Err()
	}
	// All artifacts will be in <artifact_dir>/pre-process.
	preProcessDir := path.Join(artifactDir, PreProcessName)
	// The input file name.
	inputFileName := path.Join(preProcessDir, "request.json")

	// Setting up directories.
	if err := os.MkdirAll(preProcessDir, 0755); err != nil {
		return nil, errors.Annotate(err, "prepare to run preprocess: failed to create directory %s", preProcessDir).Err()
	}
	log.Printf("Run test: created the %s directory %s", PreProcessName, preProcessDir)

	testReq := req.GetRequest()
	if err := writePreProcessInput(inputFileName, testReq); err != nil {
		return nil, errors.Annotate(err, "prepare to run preprocess: failed to create input file %s", inputFileName).Err()
	}
	if err = services.RunPreProcessCLI(ctx, preProcessContainer, networkName, preProcessDir, tokenFile); err != nil {
		return nil, errors.Annotate(err, "run preprocess: failed to run %s CLI", PreProcessName).Err()
	}

	resultFileName := path.Join(preProcessDir, "result.json")
	if _, err := os.Stat(resultFileName); os.IsNotExist(err) {
		return nil, errors.Reason("process preprocess result: result not found").Err()
	}
	outp, err := readPreProcessInput(resultFileName)
	if err != nil {
		return nil, errors.Annotate(err, "process preprocess result: failed to read preprocess output").Err()
	}

	return &api.CrosToolRunnerPreTestResponse{
		Response: outp,
	}, err
}

// writePreProcessInput writes a FilterFlakyRequest json.
func writePreProcessInput(file string, req *api.FilterFlakyRequest) error {
	f, err := os.Create(file)
	if err != nil {
		return errors.Annotate(err, "fail to create file %v", file).Err()
	}
	m := jsonpb.Marshaler{}
	if err := m.Marshal(f, req); err != nil {
		return errors.Annotate(err, "fail to marshal request to file %v", file).Err()
	}
	return nil
}

// readPreProcessInput reads output file generated by pre-process.
func readPreProcessInput(filePath string) (*api.FilterFlakyResponse, error) {
	r, err := os.Open(filePath)
	if err != nil {
		return nil, errors.Annotate(err, "read output").Err()
	}
	out := &api.FilterFlakyResponse{}

	umrsh := common.JsonPbUnmarshaler()
	err = umrsh.Unmarshal(r, out)
	return out, errors.Annotate(err, "read output").Err()
}
