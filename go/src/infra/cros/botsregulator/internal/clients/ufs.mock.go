// Copyright 2024 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Code generated by MockGen. DO NOT EDIT.
// Source: ufs.go

package clients

import (
	context "context"
	ufspb "infra/unifiedfleet/api/v1/models"
	ufspb0 "infra/unifiedfleet/api/v1/rpc"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	grpc "google.golang.org/grpc"
	protoadapt "google.golang.org/protobuf/protoadapt"
)

// MockUFSClient is a mock of UFSClient interface.
type MockUFSClient struct {
	ctrl     *gomock.Controller
	recorder *MockUFSClientMockRecorder
}

// MockUFSClientMockRecorder is the mock recorder for MockUFSClient.
type MockUFSClientMockRecorder struct {
	mock *MockUFSClient
}

// NewMockUFSClient creates a new mock instance.
func NewMockUFSClient(ctrl *gomock.Controller) *MockUFSClient {
	mock := &MockUFSClient{ctrl: ctrl}
	mock.recorder = &MockUFSClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUFSClient) EXPECT() *MockUFSClientMockRecorder {
	return m.recorder
}

// BatchListMachineLSEs mocks base method.
func (m *MockUFSClient) BatchListMachineLSEs(ctx context.Context, filters []string, pageSize int, keysOnly, full bool) ([]protoadapt.MessageV1, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BatchListMachineLSEs", ctx, filters, pageSize, keysOnly, full)
	ret0, _ := ret[0].([]protoadapt.MessageV1)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchListMachineLSEs indicates an expected call of BatchListMachineLSEs.
func (mr *MockUFSClientMockRecorder) BatchListMachineLSEs(ctx, filters, pageSize, keysOnly, full interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchListMachineLSEs", reflect.TypeOf((*MockUFSClient)(nil).BatchListMachineLSEs), ctx, filters, pageSize, keysOnly, full)
}

// BatchListMachines mocks base method.
func (m *MockUFSClient) BatchListMachines(ctx context.Context, filters []string, pageSize int, keysOnly, full bool) ([]protoadapt.MessageV1, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BatchListMachines", ctx, filters, pageSize, keysOnly, full)
	ret0, _ := ret[0].([]protoadapt.MessageV1)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchListMachines indicates an expected call of BatchListMachines.
func (mr *MockUFSClientMockRecorder) BatchListMachines(ctx, filters, pageSize, keysOnly, full interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchListMachines", reflect.TypeOf((*MockUFSClient)(nil).BatchListMachines), ctx, filters, pageSize, keysOnly, full)
}

// BatchListSchedulingUnits mocks base method.
func (m *MockUFSClient) BatchListSchedulingUnits(ctx context.Context, filters []string, pageSize int, keysOnly, full bool) ([]protoadapt.MessageV1, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BatchListSchedulingUnits", ctx, filters, pageSize, keysOnly, full)
	ret0, _ := ret[0].([]protoadapt.MessageV1)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchListSchedulingUnits indicates an expected call of BatchListSchedulingUnits.
func (mr *MockUFSClientMockRecorder) BatchListSchedulingUnits(ctx, filters, pageSize, keysOnly, full interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchListSchedulingUnits", reflect.TypeOf((*MockUFSClient)(nil).BatchListSchedulingUnits), ctx, filters, pageSize, keysOnly, full)
}

// UpdateMachineLSE mocks base method.
func (m *MockUFSClient) UpdateMachineLSE(ctx context.Context, in *ufspb0.UpdateMachineLSERequest, opts ...grpc.CallOption) (*ufspb.MachineLSE, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateMachineLSE", varargs...)
	ret0, _ := ret[0].(*ufspb.MachineLSE)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateMachineLSE indicates an expected call of UpdateMachineLSE.
func (mr *MockUFSClientMockRecorder) UpdateMachineLSE(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateMachineLSE", reflect.TypeOf((*MockUFSClient)(nil).UpdateMachineLSE), varargs...)
}
