// Code generated by protoc-gen-go. DO NOT EDIT.
// source: device.proto

/*
Package inventory is a generated protocol buffer package.

It is generated from these files:
	device.proto

It has these top-level messages:
	Device
	DeviceUnderTest
	ServoHostDevice
	ChameleonDevice
	CommonDeviceSpecs
	RemovalReason
	Location
	PhysicalLab
	DeviceLock
	Shard
	SchedulableLabels
	HardwareCapabilities
	Peripherals
	TestCoverageHints
	KeyValue
*/
package inventory

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import chrome_chromeos_infra_skylab_proto_inventory "."

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Similar to device phases, but for the cr50 module onboard.
//
// NEXT TAG: 3
type SchedulableLabels_CR50_Phase int32

const (
	SchedulableLabels_CR50_PHASE_INVALID SchedulableLabels_CR50_Phase = 0
	SchedulableLabels_CR50_PHASE_PREPVT  SchedulableLabels_CR50_Phase = 1
	SchedulableLabels_CR50_PHASE_PVT     SchedulableLabels_CR50_Phase = 2
)

var SchedulableLabels_CR50_Phase_name = map[int32]string{
	0: "CR50_PHASE_INVALID",
	1: "CR50_PHASE_PREPVT",
	2: "CR50_PHASE_PVT",
}
var SchedulableLabels_CR50_Phase_value = map[string]int32{
	"CR50_PHASE_INVALID": 0,
	"CR50_PHASE_PREPVT":  1,
	"CR50_PHASE_PVT":     2,
}

func (x SchedulableLabels_CR50_Phase) Enum() *SchedulableLabels_CR50_Phase {
	p := new(SchedulableLabels_CR50_Phase)
	*p = x
	return p
}
func (x SchedulableLabels_CR50_Phase) String() string {
	return proto.EnumName(SchedulableLabels_CR50_Phase_name, int32(x))
}
func (x *SchedulableLabels_CR50_Phase) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SchedulableLabels_CR50_Phase_value, data, "SchedulableLabels_CR50_Phase")
	if err != nil {
		return err
	}
	*x = SchedulableLabels_CR50_Phase(value)
	return nil
}
func (SchedulableLabels_CR50_Phase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 0}
}

// critical_pools are pool labels that the builders are dependent on, and that
// the cros-infra team is responsible for managing explicitly. All other pool
// labels used for adhoc labeling of DUTs go into self_serve_pools.
//
// NEXT TAG: 9
type SchedulableLabels_DUTPool int32

const (
	SchedulableLabels_DUT_POOL_INVALID       SchedulableLabels_DUTPool = 0
	SchedulableLabels_DUT_POOL_CQ            SchedulableLabels_DUTPool = 1
	SchedulableLabels_DUT_POOL_BVT           SchedulableLabels_DUTPool = 2
	SchedulableLabels_DUT_POOL_SUITES        SchedulableLabels_DUTPool = 3
	SchedulableLabels_DUT_POOL_CTS           SchedulableLabels_DUTPool = 4
	SchedulableLabels_DUT_POOL_CTS_PERBUILD  SchedulableLabels_DUTPool = 5
	SchedulableLabels_DUT_POOL_CONTINUOUS    SchedulableLabels_DUTPool = 6
	SchedulableLabels_DUT_POOL_ARC_PRESUBMIT SchedulableLabels_DUTPool = 7
	SchedulableLabels_DUT_POOL_QUOTA         SchedulableLabels_DUTPool = 8
)

var SchedulableLabels_DUTPool_name = map[int32]string{
	0: "DUT_POOL_INVALID",
	1: "DUT_POOL_CQ",
	2: "DUT_POOL_BVT",
	3: "DUT_POOL_SUITES",
	4: "DUT_POOL_CTS",
	5: "DUT_POOL_CTS_PERBUILD",
	6: "DUT_POOL_CONTINUOUS",
	7: "DUT_POOL_ARC_PRESUBMIT",
	8: "DUT_POOL_QUOTA",
}
var SchedulableLabels_DUTPool_value = map[string]int32{
	"DUT_POOL_INVALID":       0,
	"DUT_POOL_CQ":            1,
	"DUT_POOL_BVT":           2,
	"DUT_POOL_SUITES":        3,
	"DUT_POOL_CTS":           4,
	"DUT_POOL_CTS_PERBUILD":  5,
	"DUT_POOL_CONTINUOUS":    6,
	"DUT_POOL_ARC_PRESUBMIT": 7,
	"DUT_POOL_QUOTA":         8,
}

func (x SchedulableLabels_DUTPool) Enum() *SchedulableLabels_DUTPool {
	p := new(SchedulableLabels_DUTPool)
	*p = x
	return p
}
func (x SchedulableLabels_DUTPool) String() string {
	return proto.EnumName(SchedulableLabels_DUTPool_name, int32(x))
}
func (x *SchedulableLabels_DUTPool) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SchedulableLabels_DUTPool_value, data, "SchedulableLabels_DUTPool")
	if err != nil {
		return err
	}
	*x = SchedulableLabels_DUTPool(value)
	return nil
}
func (SchedulableLabels_DUTPool) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 1}
}

// NEXT TAG: 3
type SchedulableLabels_CTSABI int32

const (
	SchedulableLabels_CTS_ABI_INVALID SchedulableLabels_CTSABI = 0
	SchedulableLabels_CTS_ABI_ARM     SchedulableLabels_CTSABI = 1
	SchedulableLabels_CTS_ABI_X86     SchedulableLabels_CTSABI = 2
)

var SchedulableLabels_CTSABI_name = map[int32]string{
	0: "CTS_ABI_INVALID",
	1: "CTS_ABI_ARM",
	2: "CTS_ABI_X86",
}
var SchedulableLabels_CTSABI_value = map[string]int32{
	"CTS_ABI_INVALID": 0,
	"CTS_ABI_ARM":     1,
	"CTS_ABI_X86":     2,
}

func (x SchedulableLabels_CTSABI) Enum() *SchedulableLabels_CTSABI {
	p := new(SchedulableLabels_CTSABI)
	*p = x
	return p
}
func (x SchedulableLabels_CTSABI) String() string {
	return proto.EnumName(SchedulableLabels_CTSABI_name, int32(x))
}
func (x *SchedulableLabels_CTSABI) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SchedulableLabels_CTSABI_value, data, "SchedulableLabels_CTSABI")
	if err != nil {
		return err
	}
	*x = SchedulableLabels_CTSABI(value)
	return nil
}
func (SchedulableLabels_CTSABI) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 2} }

// NEXT TAG: 3
type SchedulableLabels_CTSCPU int32

const (
	SchedulableLabels_CTS_CPU_INVALID SchedulableLabels_CTSCPU = 0
	SchedulableLabels_CTS_CPU_ARM     SchedulableLabels_CTSCPU = 1
	SchedulableLabels_CTS_CPU_X86     SchedulableLabels_CTSCPU = 2
)

var SchedulableLabels_CTSCPU_name = map[int32]string{
	0: "CTS_CPU_INVALID",
	1: "CTS_CPU_ARM",
	2: "CTS_CPU_X86",
}
var SchedulableLabels_CTSCPU_value = map[string]int32{
	"CTS_CPU_INVALID": 0,
	"CTS_CPU_ARM":     1,
	"CTS_CPU_X86":     2,
}

func (x SchedulableLabels_CTSCPU) Enum() *SchedulableLabels_CTSCPU {
	p := new(SchedulableLabels_CTSCPU)
	*p = x
	return p
}
func (x SchedulableLabels_CTSCPU) String() string {
	return proto.EnumName(SchedulableLabels_CTSCPU_name, int32(x))
}
func (x *SchedulableLabels_CTSCPU) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SchedulableLabels_CTSCPU_value, data, "SchedulableLabels_CTSCPU")
	if err != nil {
		return err
	}
	*x = SchedulableLabels_CTSCPU(value)
	return nil
}
func (SchedulableLabels_CTSCPU) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 3} }

// NEXT TAG: 2
type SchedulableLabels_ECType int32

const (
	SchedulableLabels_EC_TYPE_INVALID   SchedulableLabels_ECType = 0
	SchedulableLabels_EC_TYPE_CHROME_OS SchedulableLabels_ECType = 1
)

var SchedulableLabels_ECType_name = map[int32]string{
	0: "EC_TYPE_INVALID",
	1: "EC_TYPE_CHROME_OS",
}
var SchedulableLabels_ECType_value = map[string]int32{
	"EC_TYPE_INVALID":   0,
	"EC_TYPE_CHROME_OS": 1,
}

func (x SchedulableLabels_ECType) Enum() *SchedulableLabels_ECType {
	p := new(SchedulableLabels_ECType)
	*p = x
	return p
}
func (x SchedulableLabels_ECType) String() string {
	return proto.EnumName(SchedulableLabels_ECType_name, int32(x))
}
func (x *SchedulableLabels_ECType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SchedulableLabels_ECType_value, data, "SchedulableLabels_ECType")
	if err != nil {
		return err
	}
	*x = SchedulableLabels_ECType(value)
	return nil
}
func (SchedulableLabels_ECType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 4} }

// NEXT TAG: 6
type SchedulableLabels_OSType int32

const (
	SchedulableLabels_OS_TYPE_INVALID    SchedulableLabels_OSType = 0
	SchedulableLabels_OS_TYPE_ANDROID    SchedulableLabels_OSType = 1
	SchedulableLabels_OS_TYPE_CROS       SchedulableLabels_OSType = 2
	SchedulableLabels_OS_TYPE_JETSTREAM  SchedulableLabels_OSType = 3
	SchedulableLabels_OS_TYPE_MOBLAB     SchedulableLabels_OSType = 4
	SchedulableLabels_OS_TYPE_LABSTATION SchedulableLabels_OSType = 5
)

var SchedulableLabels_OSType_name = map[int32]string{
	0: "OS_TYPE_INVALID",
	1: "OS_TYPE_ANDROID",
	2: "OS_TYPE_CROS",
	3: "OS_TYPE_JETSTREAM",
	4: "OS_TYPE_MOBLAB",
	5: "OS_TYPE_LABSTATION",
}
var SchedulableLabels_OSType_value = map[string]int32{
	"OS_TYPE_INVALID":    0,
	"OS_TYPE_ANDROID":    1,
	"OS_TYPE_CROS":       2,
	"OS_TYPE_JETSTREAM":  3,
	"OS_TYPE_MOBLAB":     4,
	"OS_TYPE_LABSTATION": 5,
}

func (x SchedulableLabels_OSType) Enum() *SchedulableLabels_OSType {
	p := new(SchedulableLabels_OSType)
	*p = x
	return p
}
func (x SchedulableLabels_OSType) String() string {
	return proto.EnumName(SchedulableLabels_OSType_name, int32(x))
}
func (x *SchedulableLabels_OSType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SchedulableLabels_OSType_value, data, "SchedulableLabels_OSType")
	if err != nil {
		return err
	}
	*x = SchedulableLabels_OSType(value)
	return nil
}
func (SchedulableLabels_OSType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 5} }

// Devices go through the phases EVT -> DVT -> PVT during early development.
// Post launch devices are in the MP phase.
// Certain phases end up having to be repeated as hardware evolves. Leave some
// scope for iteration within phases.
//
// NEXT TAG: 9
type SchedulableLabels_Phase int32

const (
	SchedulableLabels_PHASE_INVALID SchedulableLabels_Phase = 0
	SchedulableLabels_PHASE_EVT     SchedulableLabels_Phase = 1
	SchedulableLabels_PHASE_EVT2    SchedulableLabels_Phase = 2
	SchedulableLabels_PHASE_DVT     SchedulableLabels_Phase = 3
	SchedulableLabels_PHASE_DVT2    SchedulableLabels_Phase = 4
	SchedulableLabels_PHASE_PVT     SchedulableLabels_Phase = 5
	SchedulableLabels_PHASE_PVT2    SchedulableLabels_Phase = 6
	SchedulableLabels_PHASE_PVT3    SchedulableLabels_Phase = 7
	SchedulableLabels_PHASE_MP      SchedulableLabels_Phase = 8
)

var SchedulableLabels_Phase_name = map[int32]string{
	0: "PHASE_INVALID",
	1: "PHASE_EVT",
	2: "PHASE_EVT2",
	3: "PHASE_DVT",
	4: "PHASE_DVT2",
	5: "PHASE_PVT",
	6: "PHASE_PVT2",
	7: "PHASE_PVT3",
	8: "PHASE_MP",
}
var SchedulableLabels_Phase_value = map[string]int32{
	"PHASE_INVALID": 0,
	"PHASE_EVT":     1,
	"PHASE_EVT2":    2,
	"PHASE_DVT":     3,
	"PHASE_DVT2":    4,
	"PHASE_PVT":     5,
	"PHASE_PVT2":    6,
	"PHASE_PVT3":    7,
	"PHASE_MP":      8,
}

func (x SchedulableLabels_Phase) Enum() *SchedulableLabels_Phase {
	p := new(SchedulableLabels_Phase)
	*p = x
	return p
}
func (x SchedulableLabels_Phase) String() string {
	return proto.EnumName(SchedulableLabels_Phase_name, int32(x))
}
func (x *SchedulableLabels_Phase) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SchedulableLabels_Phase_value, data, "SchedulableLabels_Phase")
	if err != nil {
		return err
	}
	*x = SchedulableLabels_Phase(value)
	return nil
}
func (SchedulableLabels_Phase) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 6} }

// NEXT TAG: 5
type HardwareCapabilities_Carrier int32

const (
	HardwareCapabilities_CARRIER_INVALID HardwareCapabilities_Carrier = 0
	HardwareCapabilities_CARRIER_ATT     HardwareCapabilities_Carrier = 1
	HardwareCapabilities_CARRIER_TMOBILE HardwareCapabilities_Carrier = 2
	HardwareCapabilities_CARRIER_VERIZON HardwareCapabilities_Carrier = 3
	HardwareCapabilities_CARRIER_SPRINT  HardwareCapabilities_Carrier = 4
)

var HardwareCapabilities_Carrier_name = map[int32]string{
	0: "CARRIER_INVALID",
	1: "CARRIER_ATT",
	2: "CARRIER_TMOBILE",
	3: "CARRIER_VERIZON",
	4: "CARRIER_SPRINT",
}
var HardwareCapabilities_Carrier_value = map[string]int32{
	"CARRIER_INVALID": 0,
	"CARRIER_ATT":     1,
	"CARRIER_TMOBILE": 2,
	"CARRIER_VERIZON": 3,
	"CARRIER_SPRINT":  4,
}

func (x HardwareCapabilities_Carrier) Enum() *HardwareCapabilities_Carrier {
	p := new(HardwareCapabilities_Carrier)
	*p = x
	return p
}
func (x HardwareCapabilities_Carrier) String() string {
	return proto.EnumName(HardwareCapabilities_Carrier_name, int32(x))
}
func (x *HardwareCapabilities_Carrier) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(HardwareCapabilities_Carrier_value, data, "HardwareCapabilities_Carrier")
	if err != nil {
		return err
	}
	*x = HardwareCapabilities_Carrier(value)
	return nil
}
func (HardwareCapabilities_Carrier) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{11, 0}
}

// NEXT TAG: 13
type HardwareCapabilities_VideoAcceleration int32

const (
	HardwareCapabilities_VIDEO_ACCELERATION_INVALID   HardwareCapabilities_VideoAcceleration = 0
	HardwareCapabilities_VIDEO_ACCELERATION_H264      HardwareCapabilities_VideoAcceleration = 1
	HardwareCapabilities_VIDEO_ACCELERATION_ENC_H264  HardwareCapabilities_VideoAcceleration = 2
	HardwareCapabilities_VIDEO_ACCELERATION_VP8       HardwareCapabilities_VideoAcceleration = 3
	HardwareCapabilities_VIDEO_ACCELERATION_ENC_VP8   HardwareCapabilities_VideoAcceleration = 4
	HardwareCapabilities_VIDEO_ACCELERATION_VP9       HardwareCapabilities_VideoAcceleration = 5
	HardwareCapabilities_VIDEO_ACCELERATION_ENC_VP9   HardwareCapabilities_VideoAcceleration = 6
	HardwareCapabilities_VIDEO_ACCELERATION_VP9_2     HardwareCapabilities_VideoAcceleration = 7
	HardwareCapabilities_VIDEO_ACCELERATION_ENC_VP9_2 HardwareCapabilities_VideoAcceleration = 8
	HardwareCapabilities_VIDEO_ACCELERATION_H265      HardwareCapabilities_VideoAcceleration = 9
	HardwareCapabilities_VIDEO_ACCELERATION_ENC_H265  HardwareCapabilities_VideoAcceleration = 10
	HardwareCapabilities_VIDEO_ACCELERATION_MJPG      HardwareCapabilities_VideoAcceleration = 11
	HardwareCapabilities_VIDEO_ACCELERATION_ENC_MJPG  HardwareCapabilities_VideoAcceleration = 12
)

var HardwareCapabilities_VideoAcceleration_name = map[int32]string{
	0:  "VIDEO_ACCELERATION_INVALID",
	1:  "VIDEO_ACCELERATION_H264",
	2:  "VIDEO_ACCELERATION_ENC_H264",
	3:  "VIDEO_ACCELERATION_VP8",
	4:  "VIDEO_ACCELERATION_ENC_VP8",
	5:  "VIDEO_ACCELERATION_VP9",
	6:  "VIDEO_ACCELERATION_ENC_VP9",
	7:  "VIDEO_ACCELERATION_VP9_2",
	8:  "VIDEO_ACCELERATION_ENC_VP9_2",
	9:  "VIDEO_ACCELERATION_H265",
	10: "VIDEO_ACCELERATION_ENC_H265",
	11: "VIDEO_ACCELERATION_MJPG",
	12: "VIDEO_ACCELERATION_ENC_MJPG",
}
var HardwareCapabilities_VideoAcceleration_value = map[string]int32{
	"VIDEO_ACCELERATION_INVALID":   0,
	"VIDEO_ACCELERATION_H264":      1,
	"VIDEO_ACCELERATION_ENC_H264":  2,
	"VIDEO_ACCELERATION_VP8":       3,
	"VIDEO_ACCELERATION_ENC_VP8":   4,
	"VIDEO_ACCELERATION_VP9":       5,
	"VIDEO_ACCELERATION_ENC_VP9":   6,
	"VIDEO_ACCELERATION_VP9_2":     7,
	"VIDEO_ACCELERATION_ENC_VP9_2": 8,
	"VIDEO_ACCELERATION_H265":      9,
	"VIDEO_ACCELERATION_ENC_H265":  10,
	"VIDEO_ACCELERATION_MJPG":      11,
	"VIDEO_ACCELERATION_ENC_MJPG":  12,
}

func (x HardwareCapabilities_VideoAcceleration) Enum() *HardwareCapabilities_VideoAcceleration {
	p := new(HardwareCapabilities_VideoAcceleration)
	*p = x
	return p
}
func (x HardwareCapabilities_VideoAcceleration) String() string {
	return proto.EnumName(HardwareCapabilities_VideoAcceleration_name, int32(x))
}
func (x *HardwareCapabilities_VideoAcceleration) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(HardwareCapabilities_VideoAcceleration_value, data, "HardwareCapabilities_VideoAcceleration")
	if err != nil {
		return err
	}
	*x = HardwareCapabilities_VideoAcceleration(value)
	return nil
}
func (HardwareCapabilities_VideoAcceleration) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{11, 1}
}

// NEXT TAG: 9
type Peripherals_ChameleonType int32

const (
	Peripherals_CHAMELEON_TYPE_INVALID      Peripherals_ChameleonType = 0
	Peripherals_CHAMELEON_TYPE_BT_HID       Peripherals_ChameleonType = 1
	Peripherals_CHAMELEON_TYPE_DP           Peripherals_ChameleonType = 2
	Peripherals_CHAMELEON_TYPE_DP_HDMI      Peripherals_ChameleonType = 3
	Peripherals_CHAMELEON_TYPE_VGA          Peripherals_ChameleonType = 4
	Peripherals_CHAMELEON_TYPE_HDMI         Peripherals_ChameleonType = 5
	Peripherals_CHAMELEON_TYPE_BT_BLE_HID   Peripherals_ChameleonType = 6
	Peripherals_CHAMELEON_TYPE_BT_A2DP_SINK Peripherals_ChameleonType = 7
	Peripherals_CHAMELEON_TYPE_BT_PEER      Peripherals_ChameleonType = 8
)

var Peripherals_ChameleonType_name = map[int32]string{
	0: "CHAMELEON_TYPE_INVALID",
	1: "CHAMELEON_TYPE_BT_HID",
	2: "CHAMELEON_TYPE_DP",
	3: "CHAMELEON_TYPE_DP_HDMI",
	4: "CHAMELEON_TYPE_VGA",
	5: "CHAMELEON_TYPE_HDMI",
	6: "CHAMELEON_TYPE_BT_BLE_HID",
	7: "CHAMELEON_TYPE_BT_A2DP_SINK",
	8: "CHAMELEON_TYPE_BT_PEER",
}
var Peripherals_ChameleonType_value = map[string]int32{
	"CHAMELEON_TYPE_INVALID":      0,
	"CHAMELEON_TYPE_BT_HID":       1,
	"CHAMELEON_TYPE_DP":           2,
	"CHAMELEON_TYPE_DP_HDMI":      3,
	"CHAMELEON_TYPE_VGA":          4,
	"CHAMELEON_TYPE_HDMI":         5,
	"CHAMELEON_TYPE_BT_BLE_HID":   6,
	"CHAMELEON_TYPE_BT_A2DP_SINK": 7,
	"CHAMELEON_TYPE_BT_PEER":      8,
}

func (x Peripherals_ChameleonType) Enum() *Peripherals_ChameleonType {
	p := new(Peripherals_ChameleonType)
	*p = x
	return p
}
func (x Peripherals_ChameleonType) String() string {
	return proto.EnumName(Peripherals_ChameleonType_name, int32(x))
}
func (x *Peripherals_ChameleonType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Peripherals_ChameleonType_value, data, "Peripherals_ChameleonType")
	if err != nil {
		return err
	}
	*x = Peripherals_ChameleonType(value)
	return nil
}
func (Peripherals_ChameleonType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{12, 0}
}

// Related to sparse CTS testing. See b/70309087
// NEXT TAG: 4
type TestCoverageHints_CTSSparse int32

const (
	TestCoverageHints_CTS_SPARSE_INVALID TestCoverageHints_CTSSparse = 0
	TestCoverageHints_CTS_SPARSE_2       TestCoverageHints_CTSSparse = 1
	TestCoverageHints_CTS_SPARSE_3       TestCoverageHints_CTSSparse = 2
	TestCoverageHints_CTS_SPARSE_5       TestCoverageHints_CTSSparse = 3
)

var TestCoverageHints_CTSSparse_name = map[int32]string{
	0: "CTS_SPARSE_INVALID",
	1: "CTS_SPARSE_2",
	2: "CTS_SPARSE_3",
	3: "CTS_SPARSE_5",
}
var TestCoverageHints_CTSSparse_value = map[string]int32{
	"CTS_SPARSE_INVALID": 0,
	"CTS_SPARSE_2":       1,
	"CTS_SPARSE_3":       2,
	"CTS_SPARSE_5":       3,
}

func (x TestCoverageHints_CTSSparse) Enum() *TestCoverageHints_CTSSparse {
	p := new(TestCoverageHints_CTSSparse)
	*p = x
	return p
}
func (x TestCoverageHints_CTSSparse) String() string {
	return proto.EnumName(TestCoverageHints_CTSSparse_name, int32(x))
}
func (x *TestCoverageHints_CTSSparse) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TestCoverageHints_CTSSparse_value, data, "TestCoverageHints_CTSSparse")
	if err != nil {
		return err
	}
	*x = TestCoverageHints_CTSSparse(value)
	return nil
}
func (TestCoverageHints_CTSSparse) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{13, 0}
}

// NEXT TAG: 4
type Device struct {
	// Each of these must contain a 'CommonDeviceSpecs common' field.
	// We will use this informal composition based sharing rather than proto
	// extensions because extensions are unwieldy, and we really want composition
	// not inhertence.
	//
	// Types that are valid to be assigned to Device:
	//	*Device_Dut
	//	*Device_ServoHost
	//	*Device_Chameleon
	Device           isDevice_Device `protobuf_oneof:"device"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *Device) Reset()                    { *m = Device{} }
func (m *Device) String() string            { return proto.CompactTextString(m) }
func (*Device) ProtoMessage()               {}
func (*Device) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isDevice_Device interface {
	isDevice_Device()
}

type Device_Dut struct {
	Dut *DeviceUnderTest `protobuf:"bytes,1,opt,name=dut,oneof"`
}
type Device_ServoHost struct {
	ServoHost *ServoHostDevice `protobuf:"bytes,2,opt,name=servo_host,json=servoHost,oneof"`
}
type Device_Chameleon struct {
	Chameleon *ChameleonDevice `protobuf:"bytes,3,opt,name=chameleon,oneof"`
}

func (*Device_Dut) isDevice_Device()       {}
func (*Device_ServoHost) isDevice_Device() {}
func (*Device_Chameleon) isDevice_Device() {}

func (m *Device) GetDevice() isDevice_Device {
	if m != nil {
		return m.Device
	}
	return nil
}

func (m *Device) GetDut() *DeviceUnderTest {
	if x, ok := m.GetDevice().(*Device_Dut); ok {
		return x.Dut
	}
	return nil
}

func (m *Device) GetServoHost() *ServoHostDevice {
	if x, ok := m.GetDevice().(*Device_ServoHost); ok {
		return x.ServoHost
	}
	return nil
}

func (m *Device) GetChameleon() *ChameleonDevice {
	if x, ok := m.GetDevice().(*Device_Chameleon); ok {
		return x.Chameleon
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Device) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Device_OneofMarshaler, _Device_OneofUnmarshaler, _Device_OneofSizer, []interface{}{
		(*Device_Dut)(nil),
		(*Device_ServoHost)(nil),
		(*Device_Chameleon)(nil),
	}
}

func _Device_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Device)
	// device
	switch x := m.Device.(type) {
	case *Device_Dut:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Dut); err != nil {
			return err
		}
	case *Device_ServoHost:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServoHost); err != nil {
			return err
		}
	case *Device_Chameleon:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Chameleon); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Device.Device has unexpected type %T", x)
	}
	return nil
}

func _Device_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Device)
	switch tag {
	case 1: // device.dut
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DeviceUnderTest)
		err := b.DecodeMessage(msg)
		m.Device = &Device_Dut{msg}
		return true, err
	case 2: // device.servo_host
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ServoHostDevice)
		err := b.DecodeMessage(msg)
		m.Device = &Device_ServoHost{msg}
		return true, err
	case 3: // device.chameleon
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChameleonDevice)
		err := b.DecodeMessage(msg)
		m.Device = &Device_Chameleon{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Device_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Device)
	// device
	switch x := m.Device.(type) {
	case *Device_Dut:
		s := proto.Size(x.Dut)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Device_ServoHost:
		s := proto.Size(x.ServoHost)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Device_Chameleon:
		s := proto.Size(x.Chameleon)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// NEXT TAG: 2
type DeviceUnderTest struct {
	Common           *CommonDeviceSpecs `protobuf:"bytes,1,req,name=common" json:"common,omitempty"`
	RemovalReason    *RemovalReason     `protobuf:"bytes,2,opt,name=removal_reason,json=removalReason" json:"removal_reason,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *DeviceUnderTest) Reset()                    { *m = DeviceUnderTest{} }
func (m *DeviceUnderTest) String() string            { return proto.CompactTextString(m) }
func (*DeviceUnderTest) ProtoMessage()               {}
func (*DeviceUnderTest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *DeviceUnderTest) GetCommon() *CommonDeviceSpecs {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *DeviceUnderTest) GetRemovalReason() *RemovalReason {
	if m != nil {
		return m.RemovalReason
	}
	return nil
}

// NEXT TAG: 2
type ServoHostDevice struct {
	Common           *CommonDeviceSpecs `protobuf:"bytes,1,req,name=common" json:"common,omitempty"`
	Version          *string            `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *ServoHostDevice) Reset()                    { *m = ServoHostDevice{} }
func (m *ServoHostDevice) String() string            { return proto.CompactTextString(m) }
func (*ServoHostDevice) ProtoMessage()               {}
func (*ServoHostDevice) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ServoHostDevice) GetCommon() *CommonDeviceSpecs {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *ServoHostDevice) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

// NEXT TAG: 2
type ChameleonDevice struct {
	Common           *CommonDeviceSpecs `protobuf:"bytes,1,req,name=common" json:"common,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *ChameleonDevice) Reset()                    { *m = ChameleonDevice{} }
func (m *ChameleonDevice) String() string            { return proto.CompactTextString(m) }
func (*ChameleonDevice) ProtoMessage()               {}
func (*ChameleonDevice) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ChameleonDevice) GetCommon() *CommonDeviceSpecs {
	if m != nil {
		return m.Common
	}
	return nil
}

//
// Keep sorted by field name.
//
// NEXT TAG: 12
type CommonDeviceSpecs struct {
	// These are opaque keyvals for skylab services. Devices may arbitrarily
	// define any attributes they want.
	Attributes []*KeyValue `protobuf:"bytes,9,rep,name=attributes" json:"attributes,omitempty"`
	// A device may be locked for multiple reasons by multiple people. All locks
	// need to be removed for the device to go back into circulation.
	DeviceLocks []*DeviceLock                                             `protobuf:"bytes,6,rep,name=device_locks,json=deviceLocks" json:"device_locks,omitempty"`
	Environment *chrome_chromeos_infra_skylab_proto_inventory.Environment `protobuf:"varint,10,opt,name=environment,enum=chrome.chromeos_infra.skylab.proto.inventory.Environment" json:"environment,omitempty"`
	Hostname    *string                                                   `protobuf:"bytes,2,req,name=hostname" json:"hostname,omitempty"`
	// An invariant property corresponding to the hardware deployed for this
	// device.
	Hwid *string `protobuf:"bytes,3,opt,name=hwid" json:"hwid,omitempty"`
	Id   *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	// The scheduling system uses these to target jobs at the right kinds of
	// devices.
	Labels   *SchedulableLabels `protobuf:"bytes,8,opt,name=labels" json:"labels,omitempty"`
	Location *Location          `protobuf:"bytes,5,opt,name=location" json:"location,omitempty"`
	// Deprecated: This is needed for the master AFE in the autotest infra to
	// forward RPCs to the relevant shard for a device.
	// Not to be used in skylab.
	OwnerShard *Shard `protobuf:"bytes,7,opt,name=owner_shard,json=ownerShard" json:"owner_shard,omitempty"`
	// An invariant about the distros inventory tag associated with the device.
	// For ChromeOS devices, this can be read off of vboot.
	SerialNumber *string `protobuf:"bytes,4,opt,name=serial_number,json=serialNumber" json:"serial_number,omitempty"`
	// Similar to a useless machine, if set to true, automatic inventory
	// updates should set this back to false.  This can be used to test
	// that automated updates are firing correctly.
	UselessSwitch    *bool  `protobuf:"varint,11,opt,name=useless_switch,json=uselessSwitch" json:"useless_switch,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CommonDeviceSpecs) Reset()                    { *m = CommonDeviceSpecs{} }
func (m *CommonDeviceSpecs) String() string            { return proto.CompactTextString(m) }
func (*CommonDeviceSpecs) ProtoMessage()               {}
func (*CommonDeviceSpecs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *CommonDeviceSpecs) GetAttributes() []*KeyValue {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *CommonDeviceSpecs) GetDeviceLocks() []*DeviceLock {
	if m != nil {
		return m.DeviceLocks
	}
	return nil
}

func (m *CommonDeviceSpecs) GetEnvironment() chrome_chromeos_infra_skylab_proto_inventory.Environment {
	if m != nil && m.Environment != nil {
		return *m.Environment
	}
	return chrome_chromeos_infra_skylab_proto_inventory.Environment_ENVIRONMENT_INVALID
}

func (m *CommonDeviceSpecs) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *CommonDeviceSpecs) GetHwid() string {
	if m != nil && m.Hwid != nil {
		return *m.Hwid
	}
	return ""
}

func (m *CommonDeviceSpecs) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *CommonDeviceSpecs) GetLabels() *SchedulableLabels {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *CommonDeviceSpecs) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *CommonDeviceSpecs) GetOwnerShard() *Shard {
	if m != nil {
		return m.OwnerShard
	}
	return nil
}

func (m *CommonDeviceSpecs) GetSerialNumber() string {
	if m != nil && m.SerialNumber != nil {
		return *m.SerialNumber
	}
	return ""
}

func (m *CommonDeviceSpecs) GetUselessSwitch() bool {
	if m != nil && m.UselessSwitch != nil {
		return *m.UselessSwitch
	}
	return false
}

// RemovalReason describes the reason for a DUT being removed from running
// tasks. See also go/skylab-dut-removal-reason NEXT TAG: 4
type RemovalReason struct {
	// bug is a link to a bug in crbug.com or other bug tracker.  Required.
	Bug *string `protobuf:"bytes,1,opt,name=bug" json:"bug,omitempty"`
	// comment should be a short comment to provide quick context for
	// the removal reason.  This should not be used as a replacement for
	// keeping the bug up to date with context.
	Comment *string `protobuf:"bytes,2,opt,name=comment" json:"comment,omitempty"`
	// expire_time indicates when the reason for removal should be
	// revisited so that DUTs don't get forgotten.  Required.
	ExpireTime       *chrome_chromeos_infra_skylab_proto_inventory.Timestamp `protobuf:"bytes,3,opt,name=expire_time,json=expireTime" json:"expire_time,omitempty"`
	XXX_unrecognized []byte                                                  `json:"-"`
}

func (m *RemovalReason) Reset()                    { *m = RemovalReason{} }
func (m *RemovalReason) String() string            { return proto.CompactTextString(m) }
func (*RemovalReason) ProtoMessage()               {}
func (*RemovalReason) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *RemovalReason) GetBug() string {
	if m != nil && m.Bug != nil {
		return *m.Bug
	}
	return ""
}

func (m *RemovalReason) GetComment() string {
	if m != nil && m.Comment != nil {
		return *m.Comment
	}
	return ""
}

func (m *RemovalReason) GetExpireTime() *chrome_chromeos_infra_skylab_proto_inventory.Timestamp {
	if m != nil {
		return m.ExpireTime
	}
	return nil
}

// NEXT TAG: 5
type Location struct {
	Lab              *PhysicalLab `protobuf:"bytes,1,req,name=lab" json:"lab,omitempty"`
	Row              *int32       `protobuf:"varint,2,req,name=row" json:"row,omitempty"`
	Rack             *int32       `protobuf:"varint,3,req,name=rack" json:"rack,omitempty"`
	Host             *int32       `protobuf:"varint,4,req,name=host" json:"host,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *Location) Reset()                    { *m = Location{} }
func (m *Location) String() string            { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()               {}
func (*Location) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Location) GetLab() *PhysicalLab {
	if m != nil {
		return m.Lab
	}
	return nil
}

func (m *Location) GetRow() int32 {
	if m != nil && m.Row != nil {
		return *m.Row
	}
	return 0
}

func (m *Location) GetRack() int32 {
	if m != nil && m.Rack != nil {
		return *m.Rack
	}
	return 0
}

func (m *Location) GetHost() int32 {
	if m != nil && m.Host != nil {
		return *m.Host
	}
	return 0
}

// NEXT TAG: 2
type PhysicalLab struct {
	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PhysicalLab) Reset()                    { *m = PhysicalLab{} }
func (m *PhysicalLab) String() string            { return proto.CompactTextString(m) }
func (*PhysicalLab) ProtoMessage()               {}
func (*PhysicalLab) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *PhysicalLab) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

// A DeviceLock is a generic way of pulling any lab device out of commission
// temporarily. This allows us to quickly take out a device without deleting it
// from inventory. The exact effect of locking a device varies by the type of
// device and services involved.
// NEXT TAG: 6
type DeviceLock struct {
	Lock *bool `protobuf:"varint,1,req,name=lock" json:"lock,omitempty"`
	// This field is informational only. Do not assume this as a real user
	// identity in any auth domain.
	LockedBy         *string                                                 `protobuf:"bytes,2,req,name=locked_by,json=lockedBy" json:"locked_by,omitempty"`
	LockReason       *string                                                 `protobuf:"bytes,3,req,name=lock_reason,json=lockReason" json:"lock_reason,omitempty"`
	BeginTime        *chrome_chromeos_infra_skylab_proto_inventory.Timestamp `protobuf:"bytes,4,req,name=begin_time,json=beginTime" json:"begin_time,omitempty"`
	ExpireTime       *chrome_chromeos_infra_skylab_proto_inventory.Timestamp `protobuf:"bytes,5,req,name=expire_time,json=expireTime" json:"expire_time,omitempty"`
	LockId           *int32                                                  `protobuf:"varint,6,req,name=lock_id,json=lockId" json:"lock_id,omitempty"`
	Id               *string                                                 `protobuf:"bytes,7,req,name=id" json:"id,omitempty"`
	XXX_unrecognized []byte                                                  `json:"-"`
}

func (m *DeviceLock) Reset()                    { *m = DeviceLock{} }
func (m *DeviceLock) String() string            { return proto.CompactTextString(m) }
func (*DeviceLock) ProtoMessage()               {}
func (*DeviceLock) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *DeviceLock) GetLock() bool {
	if m != nil && m.Lock != nil {
		return *m.Lock
	}
	return false
}

func (m *DeviceLock) GetLockedBy() string {
	if m != nil && m.LockedBy != nil {
		return *m.LockedBy
	}
	return ""
}

func (m *DeviceLock) GetLockReason() string {
	if m != nil && m.LockReason != nil {
		return *m.LockReason
	}
	return ""
}

func (m *DeviceLock) GetBeginTime() *chrome_chromeos_infra_skylab_proto_inventory.Timestamp {
	if m != nil {
		return m.BeginTime
	}
	return nil
}

func (m *DeviceLock) GetExpireTime() *chrome_chromeos_infra_skylab_proto_inventory.Timestamp {
	if m != nil {
		return m.ExpireTime
	}
	return nil
}

func (m *DeviceLock) GetLockId() int32 {
	if m != nil && m.LockId != nil {
		return *m.LockId
	}
	return 0
}

func (m *DeviceLock) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

// NEXT TAG: 2
type Shard struct {
	Hostname         *string `protobuf:"bytes,1,req,name=hostname" json:"hostname,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Shard) Reset()                    { *m = Shard{} }
func (m *Shard) String() string            { return proto.CompactTextString(m) }
func (*Shard) ProtoMessage()               {}
func (*Shard) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Shard) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

// These labels are used for scheduling decisions in skylab. They should be
// semantically known to the inventory service to allow filtering based on them.
// (i.e., no "extra_labels" field down here)
//
// Keep sorted by field name.
//
// NEXT TAG: 33
type SchedulableLabels struct {
	// Whether this device supports ARC execution environment.
	Arc *bool `protobuf:"varint,20,opt,name=arc" json:"arc,omitempty"`
	// TODO(pprabhu) This should be an enum shared with stable_versions.proto
	// But there are 171 of them...
	Board *string `protobuf:"bytes,2,opt,name=board" json:"board,omitempty"`
	// This matches the brand id in chromiumos/infra/proto/src/device/brand_id.proto
	Brand        *string                       `protobuf:"bytes,26,opt,name=brand" json:"brand,omitempty"`
	Capabilities *HardwareCapabilities         `protobuf:"bytes,5,opt,name=capabilities" json:"capabilities,omitempty"`
	Cr50Phase    *SchedulableLabels_CR50_Phase `protobuf:"varint,22,opt,name=cr50_phase,json=cr50Phase,enum=chrome.chromeos_infra.skylab.proto.inventory.SchedulableLabels_CR50_Phase" json:"cr50_phase,omitempty"`
	// Example: cr50-ro-keyid:prod
	// Example: cr50-ro-keyid:0xaa66150f
	Cr50RoKeyid *string `protobuf:"bytes,28,opt,name=cr50_ro_keyid,json=cr50RoKeyid" json:"cr50_ro_keyid,omitempty"`
	// Example: cr50-ro-version:0.0.10
	Cr50RoVersion *string `protobuf:"bytes,29,opt,name=cr50_ro_version,json=cr50RoVersion" json:"cr50_ro_version,omitempty"`
	// Example: cr50-rw-keyid:prod
	// Example: cr50-rw-keyid:0xde88588d
	Cr50RwKeyid *string `protobuf:"bytes,30,opt,name=cr50_rw_keyid,json=cr50RwKeyid" json:"cr50_rw_keyid,omitempty"`
	// Example:cr50-rw-version:0.3.20
	Cr50RwVersion *string                     `protobuf:"bytes,31,opt,name=cr50_rw_version,json=cr50RwVersion" json:"cr50_rw_version,omitempty"`
	CriticalPools []SchedulableLabels_DUTPool `protobuf:"varint,3,rep,name=critical_pools,json=criticalPools,enum=chrome.chromeos_infra.skylab.proto.inventory.SchedulableLabels_DUTPool" json:"critical_pools,omitempty"`
	CtsAbi        []SchedulableLabels_CTSABI  `protobuf:"varint,14,rep,name=cts_abi,json=ctsAbi,enum=chrome.chromeos_infra.skylab.proto.inventory.SchedulableLabels_CTSABI" json:"cts_abi,omitempty"`
	CtsCpu        []SchedulableLabels_CTSCPU  `protobuf:"varint,21,rep,name=cts_cpu,json=ctsCpu,enum=chrome.chromeos_infra.skylab.proto.inventory.SchedulableLabels_CTSCPU" json:"cts_cpu,omitempty"`
	EcType        *SchedulableLabels_ECType   `protobuf:"varint,10,opt,name=ec_type,json=ecType,enum=chrome.chromeos_infra.skylab.proto.inventory.SchedulableLabels_ECType" json:"ec_type,omitempty"`
	HwidComponent []string                    `protobuf:"bytes,32,rep,name=hwid_component,json=hwidComponent" json:"hwid_component,omitempty"`
	// crbug.com/994200: this matches to label "sku" in autotest.
	HwidSku     *string                   `protobuf:"bytes,27,opt,name=hwid_sku,json=hwidSku" json:"hwid_sku,omitempty"`
	Model       *string                   `protobuf:"bytes,13,opt,name=model" json:"model,omitempty"`
	Sku         *string                   `protobuf:"bytes,25,opt,name=sku" json:"sku,omitempty"`
	OsType      *SchedulableLabels_OSType `protobuf:"varint,15,opt,name=os_type,json=osType,enum=chrome.chromeos_infra.skylab.proto.inventory.SchedulableLabels_OSType" json:"os_type,omitempty"`
	Peripherals *Peripherals              `protobuf:"bytes,19,opt,name=peripherals" json:"peripherals,omitempty"`
	Phase       *SchedulableLabels_Phase  `protobuf:"varint,16,opt,name=phase,enum=chrome.chromeos_infra.skylab.proto.inventory.SchedulableLabels_Phase" json:"phase,omitempty"`
	// TODO(pprabhu) This should be an enum shared with stable_versions.proto
	// But there are 171 of them...
	Platform          *string            `protobuf:"bytes,1,opt,name=platform" json:"platform,omitempty"`
	ReferenceDesign   *string            `protobuf:"bytes,24,opt,name=reference_design,json=referenceDesign" json:"reference_design,omitempty"`
	SelfServePools    []string           `protobuf:"bytes,4,rep,name=self_serve_pools,json=selfServePools" json:"self_serve_pools,omitempty"`
	TestCoverageHints *TestCoverageHints `protobuf:"bytes,18,opt,name=test_coverage_hints,json=testCoverageHints" json:"test_coverage_hints,omitempty"`
	// useless_switch does nothing.  Like a useless machine, if set to
	// true, automatic label updates should set this back to false.
	// This can be used to test that automated updates are firing
	// correctly.
	UselessSwitch    *bool    `protobuf:"varint,23,opt,name=useless_switch,json=uselessSwitch" json:"useless_switch,omitempty"`
	Variant          []string `protobuf:"bytes,17,rep,name=variant" json:"variant,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *SchedulableLabels) Reset()                    { *m = SchedulableLabels{} }
func (m *SchedulableLabels) String() string            { return proto.CompactTextString(m) }
func (*SchedulableLabels) ProtoMessage()               {}
func (*SchedulableLabels) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *SchedulableLabels) GetArc() bool {
	if m != nil && m.Arc != nil {
		return *m.Arc
	}
	return false
}

func (m *SchedulableLabels) GetBoard() string {
	if m != nil && m.Board != nil {
		return *m.Board
	}
	return ""
}

func (m *SchedulableLabels) GetBrand() string {
	if m != nil && m.Brand != nil {
		return *m.Brand
	}
	return ""
}

func (m *SchedulableLabels) GetCapabilities() *HardwareCapabilities {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

func (m *SchedulableLabels) GetCr50Phase() SchedulableLabels_CR50_Phase {
	if m != nil && m.Cr50Phase != nil {
		return *m.Cr50Phase
	}
	return SchedulableLabels_CR50_PHASE_INVALID
}

func (m *SchedulableLabels) GetCr50RoKeyid() string {
	if m != nil && m.Cr50RoKeyid != nil {
		return *m.Cr50RoKeyid
	}
	return ""
}

func (m *SchedulableLabels) GetCr50RoVersion() string {
	if m != nil && m.Cr50RoVersion != nil {
		return *m.Cr50RoVersion
	}
	return ""
}

func (m *SchedulableLabels) GetCr50RwKeyid() string {
	if m != nil && m.Cr50RwKeyid != nil {
		return *m.Cr50RwKeyid
	}
	return ""
}

func (m *SchedulableLabels) GetCr50RwVersion() string {
	if m != nil && m.Cr50RwVersion != nil {
		return *m.Cr50RwVersion
	}
	return ""
}

func (m *SchedulableLabels) GetCriticalPools() []SchedulableLabels_DUTPool {
	if m != nil {
		return m.CriticalPools
	}
	return nil
}

func (m *SchedulableLabels) GetCtsAbi() []SchedulableLabels_CTSABI {
	if m != nil {
		return m.CtsAbi
	}
	return nil
}

func (m *SchedulableLabels) GetCtsCpu() []SchedulableLabels_CTSCPU {
	if m != nil {
		return m.CtsCpu
	}
	return nil
}

func (m *SchedulableLabels) GetEcType() SchedulableLabels_ECType {
	if m != nil && m.EcType != nil {
		return *m.EcType
	}
	return SchedulableLabels_EC_TYPE_INVALID
}

func (m *SchedulableLabels) GetHwidComponent() []string {
	if m != nil {
		return m.HwidComponent
	}
	return nil
}

func (m *SchedulableLabels) GetHwidSku() string {
	if m != nil && m.HwidSku != nil {
		return *m.HwidSku
	}
	return ""
}

func (m *SchedulableLabels) GetModel() string {
	if m != nil && m.Model != nil {
		return *m.Model
	}
	return ""
}

func (m *SchedulableLabels) GetSku() string {
	if m != nil && m.Sku != nil {
		return *m.Sku
	}
	return ""
}

func (m *SchedulableLabels) GetOsType() SchedulableLabels_OSType {
	if m != nil && m.OsType != nil {
		return *m.OsType
	}
	return SchedulableLabels_OS_TYPE_INVALID
}

func (m *SchedulableLabels) GetPeripherals() *Peripherals {
	if m != nil {
		return m.Peripherals
	}
	return nil
}

func (m *SchedulableLabels) GetPhase() SchedulableLabels_Phase {
	if m != nil && m.Phase != nil {
		return *m.Phase
	}
	return SchedulableLabels_PHASE_INVALID
}

func (m *SchedulableLabels) GetPlatform() string {
	if m != nil && m.Platform != nil {
		return *m.Platform
	}
	return ""
}

func (m *SchedulableLabels) GetReferenceDesign() string {
	if m != nil && m.ReferenceDesign != nil {
		return *m.ReferenceDesign
	}
	return ""
}

func (m *SchedulableLabels) GetSelfServePools() []string {
	if m != nil {
		return m.SelfServePools
	}
	return nil
}

func (m *SchedulableLabels) GetTestCoverageHints() *TestCoverageHints {
	if m != nil {
		return m.TestCoverageHints
	}
	return nil
}

func (m *SchedulableLabels) GetUselessSwitch() bool {
	if m != nil && m.UselessSwitch != nil {
		return *m.UselessSwitch
	}
	return false
}

func (m *SchedulableLabels) GetVariant() []string {
	if m != nil {
		return m.Variant
	}
	return nil
}

// Keep sorted by field name.
//
// NEXT TAG: 20
type HardwareCapabilities struct {
	Atrus          *bool                         `protobuf:"varint,17,opt,name=atrus" json:"atrus,omitempty"`
	Bluetooth      *bool                         `protobuf:"varint,7,opt,name=bluetooth" json:"bluetooth,omitempty"`
	Carrier        *HardwareCapabilities_Carrier `protobuf:"varint,16,opt,name=carrier,enum=chrome.chromeos_infra.skylab.proto.inventory.HardwareCapabilities_Carrier" json:"carrier,omitempty"`
	Detachablebase *bool                         `protobuf:"varint,12,opt,name=detachablebase" json:"detachablebase,omitempty"`
	// Indicating if the device has fingerprint sensor.
	Fingerprint       *bool                                    `protobuf:"varint,19,opt,name=fingerprint" json:"fingerprint,omitempty"`
	Flashrom          *bool                                    `protobuf:"varint,14,opt,name=flashrom" json:"flashrom,omitempty"`
	GpuFamily         *string                                  `protobuf:"bytes,3,opt,name=gpu_family,json=gpuFamily" json:"gpu_family,omitempty"`
	Graphics          *string                                  `protobuf:"bytes,4,opt,name=graphics" json:"graphics,omitempty"`
	Hotwording        *bool                                    `protobuf:"varint,15,opt,name=hotwording" json:"hotwording,omitempty"`
	InternalDisplay   *bool                                    `protobuf:"varint,8,opt,name=internal_display,json=internalDisplay" json:"internal_display,omitempty"`
	Lucidsleep        *bool                                    `protobuf:"varint,13,opt,name=lucidsleep" json:"lucidsleep,omitempty"`
	Modem             *string                                  `protobuf:"bytes,1,opt,name=modem" json:"modem,omitempty"`
	Power             *string                                  `protobuf:"bytes,6,opt,name=power" json:"power,omitempty"`
	Storage           *string                                  `protobuf:"bytes,5,opt,name=storage" json:"storage,omitempty"`
	Telephony         *string                                  `protobuf:"bytes,2,opt,name=telephony" json:"telephony,omitempty"`
	Webcam            *bool                                    `protobuf:"varint,9,opt,name=webcam" json:"webcam,omitempty"`
	Touchpad          *bool                                    `protobuf:"varint,10,opt,name=touchpad" json:"touchpad,omitempty"`
	Touchscreen       *bool                                    `protobuf:"varint,18,opt,name=touchscreen" json:"touchscreen,omitempty"`
	VideoAcceleration []HardwareCapabilities_VideoAcceleration `protobuf:"varint,11,rep,name=video_acceleration,json=videoAcceleration,enum=chrome.chromeos_infra.skylab.proto.inventory.HardwareCapabilities_VideoAcceleration" json:"video_acceleration,omitempty"`
	XXX_unrecognized  []byte                                   `json:"-"`
}

func (m *HardwareCapabilities) Reset()                    { *m = HardwareCapabilities{} }
func (m *HardwareCapabilities) String() string            { return proto.CompactTextString(m) }
func (*HardwareCapabilities) ProtoMessage()               {}
func (*HardwareCapabilities) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *HardwareCapabilities) GetAtrus() bool {
	if m != nil && m.Atrus != nil {
		return *m.Atrus
	}
	return false
}

func (m *HardwareCapabilities) GetBluetooth() bool {
	if m != nil && m.Bluetooth != nil {
		return *m.Bluetooth
	}
	return false
}

func (m *HardwareCapabilities) GetCarrier() HardwareCapabilities_Carrier {
	if m != nil && m.Carrier != nil {
		return *m.Carrier
	}
	return HardwareCapabilities_CARRIER_INVALID
}

func (m *HardwareCapabilities) GetDetachablebase() bool {
	if m != nil && m.Detachablebase != nil {
		return *m.Detachablebase
	}
	return false
}

func (m *HardwareCapabilities) GetFingerprint() bool {
	if m != nil && m.Fingerprint != nil {
		return *m.Fingerprint
	}
	return false
}

func (m *HardwareCapabilities) GetFlashrom() bool {
	if m != nil && m.Flashrom != nil {
		return *m.Flashrom
	}
	return false
}

func (m *HardwareCapabilities) GetGpuFamily() string {
	if m != nil && m.GpuFamily != nil {
		return *m.GpuFamily
	}
	return ""
}

func (m *HardwareCapabilities) GetGraphics() string {
	if m != nil && m.Graphics != nil {
		return *m.Graphics
	}
	return ""
}

func (m *HardwareCapabilities) GetHotwording() bool {
	if m != nil && m.Hotwording != nil {
		return *m.Hotwording
	}
	return false
}

func (m *HardwareCapabilities) GetInternalDisplay() bool {
	if m != nil && m.InternalDisplay != nil {
		return *m.InternalDisplay
	}
	return false
}

func (m *HardwareCapabilities) GetLucidsleep() bool {
	if m != nil && m.Lucidsleep != nil {
		return *m.Lucidsleep
	}
	return false
}

func (m *HardwareCapabilities) GetModem() string {
	if m != nil && m.Modem != nil {
		return *m.Modem
	}
	return ""
}

func (m *HardwareCapabilities) GetPower() string {
	if m != nil && m.Power != nil {
		return *m.Power
	}
	return ""
}

func (m *HardwareCapabilities) GetStorage() string {
	if m != nil && m.Storage != nil {
		return *m.Storage
	}
	return ""
}

func (m *HardwareCapabilities) GetTelephony() string {
	if m != nil && m.Telephony != nil {
		return *m.Telephony
	}
	return ""
}

func (m *HardwareCapabilities) GetWebcam() bool {
	if m != nil && m.Webcam != nil {
		return *m.Webcam
	}
	return false
}

func (m *HardwareCapabilities) GetTouchpad() bool {
	if m != nil && m.Touchpad != nil {
		return *m.Touchpad
	}
	return false
}

func (m *HardwareCapabilities) GetTouchscreen() bool {
	if m != nil && m.Touchscreen != nil {
		return *m.Touchscreen
	}
	return false
}

func (m *HardwareCapabilities) GetVideoAcceleration() []HardwareCapabilities_VideoAcceleration {
	if m != nil {
		return m.VideoAcceleration
	}
	return nil
}

// Peripherals list peripherals connected to the device in the lab.
//
// These peripherals are not addressable as devices themselves. For peripherals
// that have complex connections with devices, create a separate device and
// connections with other devices.
//
// Keep sorted by field names.
//
// NEXT TAG: 14
type Peripherals struct {
	AudioBoard *bool `protobuf:"varint,6,opt,name=audio_board,json=audioBoard" json:"audio_board,omitempty"`
	// The DUT is housed in an audio box to record / replay audio for audio
	// testing.
	AudioBox            *bool `protobuf:"varint,7,opt,name=audio_box,json=audioBox" json:"audio_box,omitempty"`
	AudioLoopbackDongle *bool `protobuf:"varint,1,opt,name=audio_loopback_dongle,json=audioLoopbackDongle" json:"audio_loopback_dongle,omitempty"`
	// Is this device connected to a chameleon (GVC head).
	Chameleon     *bool                       `protobuf:"varint,5,opt,name=chameleon" json:"chameleon,omitempty"`
	ChameleonType []Peripherals_ChameleonType `protobuf:"varint,10,rep,name=chameleon_type,json=chameleonType,enum=chrome.chromeos_infra.skylab.proto.inventory.Peripherals_ChameleonType" json:"chameleon_type,omitempty"`
	// Whether DUT WiFi antenna is connected conductively or OTA.
	Conductive *bool `protobuf:"varint,11,opt,name=conductive" json:"conductive,omitempty"`
	Huddly     *bool `protobuf:"varint,9,opt,name=huddly" json:"huddly,omitempty"`
	Mimo       *bool `protobuf:"varint,8,opt,name=mimo" json:"mimo,omitempty"`
	// Whether a DUT has a special camera (Logitech PTZ Pro 2) connected to it.
	Ptzpro2   *bool `protobuf:"varint,12,opt,name=ptzpro2" json:"ptzpro2,omitempty"`
	Servo     *bool `protobuf:"varint,2,opt,name=servo" json:"servo,omitempty"`
	Stylus    *bool `protobuf:"varint,3,opt,name=stylus" json:"stylus,omitempty"`
	Camerabox *bool `protobuf:"varint,13,opt,name=camerabox" json:"camerabox,omitempty"`
	// Is this device inside a hermetic wifi cell.
	Wificell         *bool  `protobuf:"varint,4,opt,name=wificell" json:"wificell,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Peripherals) Reset()                    { *m = Peripherals{} }
func (m *Peripherals) String() string            { return proto.CompactTextString(m) }
func (*Peripherals) ProtoMessage()               {}
func (*Peripherals) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Peripherals) GetAudioBoard() bool {
	if m != nil && m.AudioBoard != nil {
		return *m.AudioBoard
	}
	return false
}

func (m *Peripherals) GetAudioBox() bool {
	if m != nil && m.AudioBox != nil {
		return *m.AudioBox
	}
	return false
}

func (m *Peripherals) GetAudioLoopbackDongle() bool {
	if m != nil && m.AudioLoopbackDongle != nil {
		return *m.AudioLoopbackDongle
	}
	return false
}

func (m *Peripherals) GetChameleon() bool {
	if m != nil && m.Chameleon != nil {
		return *m.Chameleon
	}
	return false
}

func (m *Peripherals) GetChameleonType() []Peripherals_ChameleonType {
	if m != nil {
		return m.ChameleonType
	}
	return nil
}

func (m *Peripherals) GetConductive() bool {
	if m != nil && m.Conductive != nil {
		return *m.Conductive
	}
	return false
}

func (m *Peripherals) GetHuddly() bool {
	if m != nil && m.Huddly != nil {
		return *m.Huddly
	}
	return false
}

func (m *Peripherals) GetMimo() bool {
	if m != nil && m.Mimo != nil {
		return *m.Mimo
	}
	return false
}

func (m *Peripherals) GetPtzpro2() bool {
	if m != nil && m.Ptzpro2 != nil {
		return *m.Ptzpro2
	}
	return false
}

func (m *Peripherals) GetServo() bool {
	if m != nil && m.Servo != nil {
		return *m.Servo
	}
	return false
}

func (m *Peripherals) GetStylus() bool {
	if m != nil && m.Stylus != nil {
		return *m.Stylus
	}
	return false
}

func (m *Peripherals) GetCamerabox() bool {
	if m != nil && m.Camerabox != nil {
		return *m.Camerabox
	}
	return false
}

func (m *Peripherals) GetWificell() bool {
	if m != nil && m.Wificell != nil {
		return *m.Wificell
	}
	return false
}

// These labels are used by the CI system to provide test coverage hints to
// Skylab.
//
// TODO(pprabhu) Most of these should instead be self-servo pools.
// Migrate the test requests to use pools and then deprecate these fields in
// favor of pools.
//
// Keep sorted by field name.
//
// NEXT TAG: 14
type TestCoverageHints struct {
	ChaosDut     *bool                         `protobuf:"varint,7,opt,name=chaos_dut,json=chaosDut" json:"chaos_dut,omitempty"`
	ChaosNightly *bool                         `protobuf:"varint,13,opt,name=chaos_nightly,json=chaosNightly" json:"chaos_nightly,omitempty"`
	Chromesign   *bool                         `protobuf:"varint,11,opt,name=chromesign" json:"chromesign,omitempty"`
	CtsSparse    []TestCoverageHints_CTSSparse `protobuf:"varint,1,rep,name=cts_sparse,json=ctsSparse,enum=chrome.chromeos_infra.skylab.proto.inventory.TestCoverageHints_CTSSparse" json:"cts_sparse,omitempty"`
	// Whether the DUT has the hangout app installed.
	// This is a software feature of the DUT that is not provisioned as part of
	// the test setup, hence the DUT must be labelled explicitly as supporting
	// this feature.  Should probably be a SoftwareFeature for the DUT.
	HangoutApp *bool `protobuf:"varint,9,opt,name=hangout_app,json=hangoutApp" json:"hangout_app,omitempty"`
	// Whether the DUT has the meet app installed.
	// This is a software feature of the DUT that is not provisioned as part of
	// the test setup, hence the DUT must be labelled explicitly as supporting
	// this feature.  Should probably be a SoftwareFeature for the DUT.
	MeetApp          *bool  `protobuf:"varint,10,opt,name=meet_app,json=meetApp" json:"meet_app,omitempty"`
	RecoveryTest     *bool  `protobuf:"varint,8,opt,name=recovery_test,json=recoveryTest" json:"recovery_test,omitempty"`
	TestAudiojack    *bool  `protobuf:"varint,3,opt,name=test_audiojack,json=testAudiojack" json:"test_audiojack,omitempty"`
	TestHdmiaudio    *bool  `protobuf:"varint,2,opt,name=test_hdmiaudio,json=testHdmiaudio" json:"test_hdmiaudio,omitempty"`
	TestUsbaudio     *bool  `protobuf:"varint,4,opt,name=test_usbaudio,json=testUsbaudio" json:"test_usbaudio,omitempty"`
	TestUsbprinting  *bool  `protobuf:"varint,5,opt,name=test_usbprinting,json=testUsbprinting" json:"test_usbprinting,omitempty"`
	UsbDetect        *bool  `protobuf:"varint,6,opt,name=usb_detect,json=usbDetect" json:"usb_detect,omitempty"`
	UseLid           *bool  `protobuf:"varint,12,opt,name=use_lid,json=useLid" json:"use_lid,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *TestCoverageHints) Reset()                    { *m = TestCoverageHints{} }
func (m *TestCoverageHints) String() string            { return proto.CompactTextString(m) }
func (*TestCoverageHints) ProtoMessage()               {}
func (*TestCoverageHints) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *TestCoverageHints) GetChaosDut() bool {
	if m != nil && m.ChaosDut != nil {
		return *m.ChaosDut
	}
	return false
}

func (m *TestCoverageHints) GetChaosNightly() bool {
	if m != nil && m.ChaosNightly != nil {
		return *m.ChaosNightly
	}
	return false
}

func (m *TestCoverageHints) GetChromesign() bool {
	if m != nil && m.Chromesign != nil {
		return *m.Chromesign
	}
	return false
}

func (m *TestCoverageHints) GetCtsSparse() []TestCoverageHints_CTSSparse {
	if m != nil {
		return m.CtsSparse
	}
	return nil
}

func (m *TestCoverageHints) GetHangoutApp() bool {
	if m != nil && m.HangoutApp != nil {
		return *m.HangoutApp
	}
	return false
}

func (m *TestCoverageHints) GetMeetApp() bool {
	if m != nil && m.MeetApp != nil {
		return *m.MeetApp
	}
	return false
}

func (m *TestCoverageHints) GetRecoveryTest() bool {
	if m != nil && m.RecoveryTest != nil {
		return *m.RecoveryTest
	}
	return false
}

func (m *TestCoverageHints) GetTestAudiojack() bool {
	if m != nil && m.TestAudiojack != nil {
		return *m.TestAudiojack
	}
	return false
}

func (m *TestCoverageHints) GetTestHdmiaudio() bool {
	if m != nil && m.TestHdmiaudio != nil {
		return *m.TestHdmiaudio
	}
	return false
}

func (m *TestCoverageHints) GetTestUsbaudio() bool {
	if m != nil && m.TestUsbaudio != nil {
		return *m.TestUsbaudio
	}
	return false
}

func (m *TestCoverageHints) GetTestUsbprinting() bool {
	if m != nil && m.TestUsbprinting != nil {
		return *m.TestUsbprinting
	}
	return false
}

func (m *TestCoverageHints) GetUsbDetect() bool {
	if m != nil && m.UsbDetect != nil {
		return *m.UsbDetect
	}
	return false
}

func (m *TestCoverageHints) GetUseLid() bool {
	if m != nil && m.UseLid != nil {
		return *m.UseLid
	}
	return false
}

// NEXT TAG: 3
type KeyValue struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *KeyValue) Reset()                    { *m = KeyValue{} }
func (m *KeyValue) String() string            { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()               {}
func (*KeyValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *KeyValue) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *KeyValue) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

func init() {
	proto.RegisterType((*Device)(nil), "chrome.chromeos_infra.skylab.proto.inventory.Device")
	proto.RegisterType((*DeviceUnderTest)(nil), "chrome.chromeos_infra.skylab.proto.inventory.DeviceUnderTest")
	proto.RegisterType((*ServoHostDevice)(nil), "chrome.chromeos_infra.skylab.proto.inventory.ServoHostDevice")
	proto.RegisterType((*ChameleonDevice)(nil), "chrome.chromeos_infra.skylab.proto.inventory.ChameleonDevice")
	proto.RegisterType((*CommonDeviceSpecs)(nil), "chrome.chromeos_infra.skylab.proto.inventory.CommonDeviceSpecs")
	proto.RegisterType((*RemovalReason)(nil), "chrome.chromeos_infra.skylab.proto.inventory.RemovalReason")
	proto.RegisterType((*Location)(nil), "chrome.chromeos_infra.skylab.proto.inventory.Location")
	proto.RegisterType((*PhysicalLab)(nil), "chrome.chromeos_infra.skylab.proto.inventory.PhysicalLab")
	proto.RegisterType((*DeviceLock)(nil), "chrome.chromeos_infra.skylab.proto.inventory.DeviceLock")
	proto.RegisterType((*Shard)(nil), "chrome.chromeos_infra.skylab.proto.inventory.Shard")
	proto.RegisterType((*SchedulableLabels)(nil), "chrome.chromeos_infra.skylab.proto.inventory.SchedulableLabels")
	proto.RegisterType((*HardwareCapabilities)(nil), "chrome.chromeos_infra.skylab.proto.inventory.HardwareCapabilities")
	proto.RegisterType((*Peripherals)(nil), "chrome.chromeos_infra.skylab.proto.inventory.Peripherals")
	proto.RegisterType((*TestCoverageHints)(nil), "chrome.chromeos_infra.skylab.proto.inventory.TestCoverageHints")
	proto.RegisterType((*KeyValue)(nil), "chrome.chromeos_infra.skylab.proto.inventory.KeyValue")
	proto.RegisterEnum("chrome.chromeos_infra.skylab.proto.inventory.SchedulableLabels_CR50_Phase", SchedulableLabels_CR50_Phase_name, SchedulableLabels_CR50_Phase_value)
	proto.RegisterEnum("chrome.chromeos_infra.skylab.proto.inventory.SchedulableLabels_DUTPool", SchedulableLabels_DUTPool_name, SchedulableLabels_DUTPool_value)
	proto.RegisterEnum("chrome.chromeos_infra.skylab.proto.inventory.SchedulableLabels_CTSABI", SchedulableLabels_CTSABI_name, SchedulableLabels_CTSABI_value)
	proto.RegisterEnum("chrome.chromeos_infra.skylab.proto.inventory.SchedulableLabels_CTSCPU", SchedulableLabels_CTSCPU_name, SchedulableLabels_CTSCPU_value)
	proto.RegisterEnum("chrome.chromeos_infra.skylab.proto.inventory.SchedulableLabels_ECType", SchedulableLabels_ECType_name, SchedulableLabels_ECType_value)
	proto.RegisterEnum("chrome.chromeos_infra.skylab.proto.inventory.SchedulableLabels_OSType", SchedulableLabels_OSType_name, SchedulableLabels_OSType_value)
	proto.RegisterEnum("chrome.chromeos_infra.skylab.proto.inventory.SchedulableLabels_Phase", SchedulableLabels_Phase_name, SchedulableLabels_Phase_value)
	proto.RegisterEnum("chrome.chromeos_infra.skylab.proto.inventory.HardwareCapabilities_Carrier", HardwareCapabilities_Carrier_name, HardwareCapabilities_Carrier_value)
	proto.RegisterEnum("chrome.chromeos_infra.skylab.proto.inventory.HardwareCapabilities_VideoAcceleration", HardwareCapabilities_VideoAcceleration_name, HardwareCapabilities_VideoAcceleration_value)
	proto.RegisterEnum("chrome.chromeos_infra.skylab.proto.inventory.Peripherals_ChameleonType", Peripherals_ChameleonType_name, Peripherals_ChameleonType_value)
	proto.RegisterEnum("chrome.chromeos_infra.skylab.proto.inventory.TestCoverageHints_CTSSparse", TestCoverageHints_CTSSparse_name, TestCoverageHints_CTSSparse_value)
}

func init() { proto.RegisterFile("device.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 2647 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x59, 0xdb, 0x6e, 0xeb, 0xc6,
	0xd5, 0x8e, 0x24, 0xeb, 0xb4, 0x64, 0xd9, 0xf4, 0xec, 0x13, 0xf7, 0x21, 0x89, 0x7f, 0x6d, 0x24,
	0xf0, 0x0f, 0x14, 0x46, 0xa0, 0x64, 0xa7, 0x09, 0x8a, 0x22, 0xd0, 0x29, 0xb1, 0xf6, 0x96, 0x2d,
	0x65, 0x24, 0xbb, 0x39, 0xa0, 0x25, 0x28, 0x72, 0x6c, 0x31, 0xa6, 0x48, 0x82, 0x43, 0xda, 0x51,
	0x6f, 0x5b, 0xb4, 0xd7, 0x45, 0xd1, 0x37, 0x68, 0xdf, 0xa1, 0xb7, 0x7d, 0x80, 0xf6, 0x29, 0xfa,
	0x02, 0xed, 0x13, 0x14, 0x6b, 0x0d, 0x29, 0xd1, 0xb2, 0x77, 0x00, 0x6f, 0x27, 0x57, 0x9e, 0xf5,
	0xad, 0x99, 0x6f, 0x38, 0x33, 0x6b, 0x7d, 0xb3, 0x46, 0x86, 0x4d, 0x5b, 0x5c, 0x38, 0x96, 0xd8,
	0x0f, 0x42, 0x3f, 0xf2, 0xd9, 0xcf, 0xac, 0x59, 0xe8, 0xcf, 0xc5, 0xbe, 0xfa, 0xe3, 0x4b, 0xc3,
	0xf1, 0x4e, 0x43, 0x73, 0x5f, 0x9e, 0x2f, 0x5c, 0x73, 0xaa, 0xfa, 0xec, 0x3b, 0xde, 0x85, 0xf0,
	0x22, 0x3f, 0x5c, 0x3c, 0xd9, 0xb4, 0xfc, 0xf9, 0xdc, 0xf7, 0x14, 0xde, 0xf8, 0x6b, 0x1e, 0x4a,
	0x5d, 0x22, 0x63, 0x5f, 0x42, 0xc1, 0x8e, 0x23, 0x3d, 0xb7, 0x9b, 0xdb, 0xab, 0x35, 0x7f, 0xb9,
	0x7f, 0x1b, 0xd2, 0x7d, 0x45, 0x71, 0xec, 0xd9, 0x22, 0x9c, 0x08, 0x19, 0x1d, 0xbc, 0xc5, 0x91,
	0x8b, 0xfd, 0x06, 0x40, 0x8a, 0xf0, 0xc2, 0x37, 0x66, 0xbe, 0x8c, 0xf4, 0xfc, 0x9b, 0x30, 0x8f,
	0x71, 0xfc, 0x81, 0x2f, 0x23, 0x35, 0xc5, 0xc1, 0x5b, 0xbc, 0x2a, 0x53, 0x88, 0xfd, 0x1a, 0xaa,
	0xd6, 0xcc, 0x9c, 0x0b, 0x57, 0xf8, 0x9e, 0x5e, 0x78, 0x13, 0xfa, 0x4e, 0x3a, 0x7c, 0x45, 0xbf,
	0x64, 0x6c, 0x57, 0xa0, 0xa4, 0x36, 0xba, 0xf1, 0xaf, 0x1c, 0x6c, 0xaf, 0xad, 0x91, 0xfd, 0x0a,
	0x4a, 0x6a, 0x2b, 0xf5, 0xdc, 0x6e, 0x7e, 0xaf, 0xd6, 0xfc, 0xec, 0x96, 0x33, 0xd3, 0x58, 0x45,
	0x3a, 0x0e, 0x84, 0x25, 0x79, 0x42, 0xc7, 0xa6, 0xb0, 0x15, 0x8a, 0xb9, 0x7f, 0x61, 0xba, 0x46,
	0x28, 0x4c, 0xe9, 0x7b, 0xc9, 0xce, 0xfd, 0xe2, 0x76, 0x13, 0x70, 0xc5, 0xc1, 0x89, 0x82, 0xd7,
	0xc3, 0xac, 0xd9, 0xf8, 0x7d, 0x0e, 0xb6, 0xd7, 0xb6, 0xf6, 0xa7, 0x5b, 0x90, 0x0e, 0xe5, 0x0b,
	0x11, 0x4a, 0x27, 0x59, 0x49, 0x95, 0xa7, 0x66, 0xe3, 0x3b, 0xd8, 0x5e, 0x3b, 0x81, 0x9f, 0xec,
	0x2b, 0x1a, 0x7f, 0x2f, 0xc2, 0xce, 0x35, 0x2f, 0x3b, 0x01, 0x30, 0xa3, 0x28, 0x74, 0xa6, 0x71,
	0x24, 0xa4, 0x5e, 0xdd, 0x2d, 0xec, 0xd5, 0x9a, 0x1f, 0xdf, 0x6e, 0xca, 0x57, 0x62, 0x71, 0x62,
	0xba, 0xb1, 0xe0, 0x19, 0x26, 0xf6, 0x6d, 0x9a, 0xa4, 0x86, 0xeb, 0x5b, 0xe7, 0x52, 0x2f, 0x11,
	0xf3, 0x27, 0x6f, 0x92, 0x56, 0x03, 0xdf, 0x3a, 0xe7, 0x35, 0x7b, 0xd9, 0x46, 0xf2, 0x9a, 0xf0,
	0x2e, 0x9c, 0xd0, 0xf7, 0xe6, 0xc2, 0x8b, 0x74, 0xd8, 0xcd, 0xed, 0x6d, 0x35, 0x3f, 0xbd, 0x1d,
	0x77, 0x6f, 0x45, 0xc0, 0xb3, 0x6c, 0xec, 0x09, 0x54, 0x30, 0x5d, 0x3d, 0x73, 0x2e, 0xf4, 0xfc,
	0x6e, 0x7e, 0xaf, 0xca, 0x97, 0x36, 0x63, 0xb0, 0x31, 0xbb, 0x74, 0x6c, 0xca, 0xb5, 0x2a, 0xa7,
	0x36, 0xdb, 0x82, 0xbc, 0x63, 0xd3, 0x61, 0x55, 0x79, 0xde, 0xb1, 0xf1, 0x00, 0x5d, 0x73, 0x2a,
	0x5c, 0xa9, 0x57, 0x28, 0x6c, 0x6f, 0x79, 0x80, 0x63, 0x6b, 0x26, 0xec, 0xd8, 0x35, 0xa7, 0xae,
	0x18, 0x10, 0x0d, 0x4f, 0xe8, 0x18, 0x87, 0x8a, 0xeb, 0x5b, 0x66, 0x84, 0x71, 0x54, 0x24, 0xea,
	0x5b, 0x1e, 0xd4, 0x20, 0x19, 0xcd, 0x97, 0x3c, 0xec, 0x2b, 0xa8, 0xf9, 0x97, 0x9e, 0x08, 0x0d,
	0x39, 0x33, 0x43, 0x5b, 0x2f, 0x13, 0xed, 0x87, 0xb7, 0xfc, 0x62, 0x1c, 0xda, 0xce, 0xeb, 0x39,
	0x0e, 0xc4, 0x45, 0x36, 0x7b, 0x0e, 0x75, 0x29, 0x42, 0xc7, 0x74, 0x0d, 0x2f, 0x9e, 0x4f, 0x45,
	0xa8, 0x6f, 0xd0, 0x9e, 0x6d, 0x2a, 0xf0, 0x88, 0x30, 0xf6, 0x1e, 0x6c, 0xc5, 0x52, 0xb8, 0x42,
	0x4a, 0x43, 0x5e, 0x3a, 0x91, 0x35, 0xd3, 0x6b, 0xbb, 0xb9, 0xbd, 0x0a, 0xaf, 0x27, 0xe8, 0x98,
	0xc0, 0xc6, 0x5f, 0x72, 0x50, 0xbf, 0x92, 0xce, 0x4c, 0x83, 0xc2, 0x34, 0x3e, 0x23, 0xb1, 0xae,
	0x72, 0x6c, 0x62, 0x92, 0x61, 0xa0, 0x63, 0x3c, 0x24, 0x49, 0x96, 0x98, 0xb8, 0x46, 0xf1, 0x7d,
	0xe0, 0x84, 0xc2, 0x88, 0x9c, 0xb9, 0x48, 0x74, 0xf2, 0xe7, 0xb7, 0x5b, 0xe3, 0xc4, 0x99, 0x0b,
	0x19, 0x99, 0xf3, 0x80, 0x83, 0xe2, 0x42, 0xa0, 0xf1, 0xa7, 0x1c, 0x54, 0xd2, 0x4d, 0x65, 0xaf,
	0xa0, 0xe0, 0x9a, 0xd3, 0x24, 0x6b, 0x6f, 0x19, 0x8c, 0xa3, 0xd9, 0x42, 0x3a, 0x96, 0xe9, 0x0e,
	0xcc, 0x29, 0x47, 0x16, 0x5c, 0x5f, 0xe8, 0x5f, 0x52, 0xfc, 0x15, 0x39, 0x36, 0x31, 0xf4, 0x42,
	0xd3, 0x3a, 0xd7, 0x0b, 0x04, 0x51, 0x9b, 0xc2, 0x11, 0x6f, 0x96, 0x0d, 0x85, 0x61, 0xbb, 0xf1,
	0x7f, 0x50, 0xcb, 0xb0, 0x61, 0x17, 0x8a, 0x64, 0x15, 0x9f, 0xd4, 0x6e, 0xfc, 0x23, 0x0f, 0xb0,
	0x4a, 0x2d, 0xf6, 0x10, 0x36, 0x30, 0x47, 0xa9, 0x4b, 0x85, 0xce, 0x91, 0x6c, 0xf6, 0x14, 0xaa,
	0xf8, 0x57, 0xd8, 0xc6, 0x74, 0x91, 0x66, 0x82, 0x02, 0xda, 0x0b, 0xf6, 0x2e, 0xd4, 0xb0, 0x9d,
	0x2a, 0x74, 0x81, 0xdc, 0x80, 0x50, 0x72, 0x42, 0x27, 0x00, 0x53, 0x71, 0xe6, 0x78, 0x6a, 0xd3,
	0x37, 0x68, 0x57, 0xde, 0x78, 0xd3, 0xab, 0x44, 0x85, 0xf6, 0xfa, 0x69, 0x16, 0xef, 0x46, 0x9c,
	0x39, 0x4d, 0xf6, 0x14, 0xca, 0xb4, 0x24, 0xc7, 0xd6, 0x4b, 0xb8, 0xa1, 0xb4, 0x15, 0x25, 0x84,
	0xfa, 0x69, 0x96, 0x97, 0xd3, 0x2c, 0x6f, 0x3c, 0x87, 0xa2, 0x8a, 0xf3, 0xac, 0x5c, 0xe4, 0xae,
	0xca, 0x45, 0xe3, 0xbf, 0x3b, 0xb0, 0x73, 0x2d, 0x9f, 0xf1, 0x6c, 0xcd, 0xd0, 0xd2, 0xef, 0x53,
	0xa4, 0x63, 0x93, 0xdd, 0x87, 0xe2, 0xd4, 0xc7, 0xfc, 0x53, 0x91, 0xab, 0x0c, 0x42, 0x43, 0xd3,
	0xb3, 0xf5, 0x27, 0x09, 0x8a, 0x06, 0x3b, 0x85, 0x4d, 0xcb, 0x0c, 0xcc, 0xa9, 0xe3, 0x3a, 0x91,
	0x23, 0x64, 0xa2, 0x04, 0xed, 0xdb, 0x6d, 0xc0, 0x81, 0x19, 0xda, 0x97, 0x66, 0x28, 0x3a, 0x19,
	0x26, 0x7e, 0x85, 0x97, 0x39, 0x00, 0x56, 0xf8, 0xe2, 0x03, 0x23, 0x98, 0x99, 0x52, 0xe8, 0x0f,
	0x49, 0x62, 0x5f, 0xde, 0x51, 0xca, 0xf6, 0x3b, 0xfc, 0xc5, 0x07, 0xc6, 0x08, 0x19, 0x79, 0x15,
	0xd9, 0xa9, 0xc9, 0x1a, 0x50, 0xa7, 0xa9, 0x42, 0xdf, 0x38, 0x17, 0x0b, 0xc7, 0xd6, 0x9f, 0xd1,
	0x82, 0x6b, 0x08, 0x72, 0xff, 0x15, 0x42, 0xec, 0x7d, 0xd8, 0x4e, 0xfb, 0xa4, 0x77, 0xe9, 0xdb,
	0xd4, 0xab, 0xae, 0x7a, 0x9d, 0x28, 0x70, 0xc5, 0x75, 0x99, 0x70, 0xbd, 0x93, 0xe1, 0xba, 0x5c,
	0xe3, 0xba, 0x5c, 0x72, 0xbd, 0x9b, 0xe1, 0xba, 0x4c, 0xb9, 0x3c, 0xd8, 0xb2, 0x42, 0x27, 0xc2,
	0x54, 0x32, 0x02, 0xdf, 0x77, 0xa5, 0x5e, 0xd8, 0x2d, 0xec, 0x6d, 0x35, 0xbf, 0xb8, 0xeb, 0x36,
	0x74, 0x8f, 0x27, 0x23, 0xdf, 0x77, 0x71, 0x3e, 0x45, 0x8f, 0x96, 0x64, 0x06, 0x94, 0xad, 0x48,
	0x1a, 0xe6, 0xd4, 0xd1, 0xb7, 0x68, 0xa2, 0xcf, 0xef, 0xbc, 0xdf, 0x93, 0x71, 0xab, 0xdd, 0xe7,
	0x25, 0x2b, 0x92, 0xad, 0xa9, 0x93, 0x4e, 0x60, 0x05, 0xb1, 0xfe, 0xe0, 0x47, 0x9b, 0xa0, 0x33,
	0x3a, 0xa6, 0x09, 0x3a, 0x41, 0x8c, 0x13, 0x08, 0xcb, 0x88, 0x16, 0x81, 0x48, 0x2e, 0xe5, 0x3b,
	0x4f, 0xd0, 0xeb, 0x4c, 0x16, 0x81, 0xe0, 0x25, 0x61, 0xe1, 0x5f, 0xbc, 0x30, 0xf0, 0xd2, 0x35,
	0x2c, 0x7f, 0x1e, 0xf8, 0x1e, 0x8a, 0xfd, 0xee, 0x6e, 0x01, 0x4f, 0x0e, 0xd1, 0x4e, 0x0a, 0xb2,
	0xc7, 0x50, 0xa1, 0x6e, 0xf2, 0x3c, 0xd6, 0x9f, 0xaa, 0xdb, 0x00, 0xed, 0xf1, 0x79, 0x8c, 0x59,
	0x35, 0xf7, 0x6d, 0xe1, 0xea, 0x75, 0x95, 0x55, 0x64, 0x60, 0x4e, 0x62, 0xdf, 0xc7, 0xea, 0x3e,
	0x91, 0xe7, 0xb4, 0x14, 0x5f, 0xaa, 0xa5, 0x6c, 0xff, 0x38, 0x4b, 0x19, 0x8e, 0xd5, 0x52, 0x7c,
	0x49, 0x4b, 0xf9, 0x16, 0x6a, 0x81, 0x08, 0x9d, 0x60, 0x26, 0x42, 0xd3, 0x95, 0xfa, 0x3d, 0xca,
	0xe3, 0xdb, 0xde, 0x1b, 0x2b, 0x02, 0x9e, 0x65, 0x63, 0xdf, 0x42, 0x51, 0x25, 0xae, 0x46, 0xdf,
	0xde, 0xbb, 0xeb, 0xb7, 0xab, 0x9c, 0x55, 0x9c, 0x28, 0x79, 0x81, 0x6b, 0x46, 0xa7, 0x7e, 0x38,
	0x4f, 0x6e, 0xe0, 0xa5, 0xcd, 0xfe, 0x1f, 0xb4, 0x50, 0x9c, 0x8a, 0x50, 0x78, 0x96, 0x30, 0x6c,
	0x21, 0x9d, 0x33, 0x4f, 0xd7, 0xa9, 0xcf, 0xf6, 0x12, 0xef, 0x12, 0xcc, 0xf6, 0x40, 0x93, 0xc2,
	0x3d, 0x35, 0xf0, 0x3d, 0x23, 0x92, 0x04, 0xdb, 0xa0, 0xd3, 0xdc, 0x42, 0x1c, 0xcb, 0x73, 0xa1,
	0x12, 0xc3, 0x87, 0x7b, 0x91, 0x90, 0x91, 0x61, 0xf9, 0x17, 0x22, 0x34, 0xcf, 0x84, 0x31, 0x73,
	0xbc, 0x48, 0xea, 0xec, 0x4d, 0xea, 0x2b, 0x7c, 0xbb, 0x74, 0x12, 0x9e, 0x03, 0xa4, 0xe1, 0x3b,
	0xd1, 0x3a, 0x74, 0x43, 0x5d, 0xf2, 0xe8, 0x86, 0xba, 0x84, 0x0a, 0x7b, 0x33, 0x74, 0x4c, 0x2f,
	0xd2, 0x77, 0xe8, 0xc3, 0x53, 0xb3, 0x31, 0x04, 0x58, 0x69, 0x1d, 0x7b, 0x08, 0x4c, 0x59, 0x07,
	0xad, 0x71, 0xcf, 0xe8, 0x1f, 0x9d, 0xb4, 0x06, 0xfd, 0xae, 0xf6, 0x16, 0x7b, 0x00, 0x3b, 0x19,
	0x7c, 0xc4, 0x7b, 0xa3, 0x93, 0x89, 0x96, 0x63, 0x0c, 0xb6, 0xb2, 0xf0, 0xc9, 0x44, 0xcb, 0x37,
	0xfe, 0x99, 0x83, 0x72, 0x22, 0x1b, 0xec, 0x3e, 0x68, 0xdd, 0xe3, 0x89, 0x31, 0x1a, 0x0e, 0x07,
	0x19, 0xb2, 0x6d, 0xa8, 0x2d, 0xd1, 0xce, 0x97, 0x5a, 0x8e, 0x69, 0xb0, 0xb9, 0x04, 0xda, 0x48,
	0xc2, 0xee, 0xc1, 0xf6, 0x12, 0x19, 0x1f, 0xf7, 0x27, 0xbd, 0xb1, 0x56, 0xb8, 0xd2, 0xad, 0x33,
	0x19, 0x6b, 0x1b, 0xec, 0x31, 0x3c, 0xc8, 0x22, 0xc6, 0xa8, 0xc7, 0xdb, 0xc7, 0xfd, 0x41, 0x57,
	0x2b, 0xb2, 0x47, 0x70, 0x6f, 0xe5, 0x1a, 0x1e, 0x4d, 0xfa, 0x47, 0xc7, 0xc3, 0xe3, 0xb1, 0x56,
	0x62, 0x4f, 0xe0, 0xe1, 0xd2, 0xd1, 0xe2, 0x1d, 0x5c, 0xcc, 0xf8, 0xb8, 0x7d, 0xd8, 0x9f, 0x68,
	0x65, 0x5c, 0xcf, 0xd2, 0xf7, 0xe5, 0xf1, 0x70, 0xd2, 0xd2, 0x2a, 0x8d, 0xcf, 0xa0, 0xa4, 0xc4,
	0x09, 0x3f, 0x0a, 0x27, 0x69, 0xb5, 0xfb, 0x57, 0x17, 0x93, 0x82, 0x2d, 0x7e, 0xa8, 0xe5, 0xb2,
	0xc0, 0x57, 0x9f, 0x7c, 0xac, 0xe5, 0x13, 0x82, 0xce, 0xe8, 0x38, 0x25, 0xe8, 0x8c, 0x8e, 0xaf,
	0x13, 0x20, 0x78, 0x85, 0x00, 0x01, 0x45, 0xf0, 0x11, 0x94, 0x94, 0xb8, 0x20, 0x41, 0xaf, 0x63,
	0x4c, 0xbe, 0x1e, 0xad, 0x9d, 0x4d, 0x0a, 0x76, 0x0e, 0xf8, 0xf0, 0xb0, 0x67, 0x0c, 0xc7, 0x5a,
	0xae, 0xf1, 0xc7, 0x1c, 0x94, 0x54, 0x22, 0xe3, 0xb0, 0xe1, 0x78, 0x7d, 0x58, 0x06, 0x6c, 0x1d,
	0x75, 0xf9, 0xb0, 0xdf, 0x55, 0x27, 0x91, 0x82, 0x1d, 0x3e, 0x1c, 0x6b, 0x79, 0x64, 0x4f, 0x91,
	0x97, 0xbd, 0xc9, 0x78, 0xc2, 0x7b, 0xad, 0x43, 0xad, 0x80, 0x3b, 0x95, 0xc2, 0x87, 0xc3, 0xf6,
	0xa0, 0xd5, 0xd6, 0x36, 0x30, 0x78, 0x52, 0x6c, 0xd0, 0x6a, 0x8f, 0x27, 0xad, 0x49, 0x7f, 0x78,
	0xa4, 0x15, 0xb1, 0x28, 0x2e, 0xaa, 0xf0, 0xda, 0x81, 0xfa, 0x7a, 0x64, 0xd5, 0xa1, 0xaa, 0xa0,
	0x1e, 0x45, 0xd4, 0x16, 0xc0, 0xd2, 0x6c, 0x6a, 0xf9, 0x95, 0xbb, 0x7b, 0x32, 0xd1, 0x0a, 0x2b,
	0x77, 0x17, 0xdd, 0x1b, 0x2b, 0x37, 0xc6, 0x5e, 0x71, 0xe5, 0x1e, 0xa1, 0xbb, 0x74, 0xc5, 0xfe,
	0x50, 0x2b, 0xb3, 0x4d, 0xa8, 0x28, 0xfb, 0x70, 0xa4, 0x55, 0x1a, 0x7f, 0x06, 0xb8, 0x7f, 0x53,
	0x7d, 0x81, 0xca, 0x6b, 0x46, 0x61, 0x2c, 0xf5, 0x1d, 0xca, 0x25, 0x65, 0xb0, 0x67, 0x50, 0x9d,
	0xba, 0xb1, 0x88, 0x7c, 0x3f, 0x9a, 0xd1, 0xfb, 0xa3, 0xc2, 0x57, 0x00, 0xb3, 0xa1, 0x6c, 0x99,
	0x61, 0xe8, 0x88, 0x30, 0x51, 0xb2, 0x97, 0x77, 0x2f, 0x74, 0xf6, 0x3b, 0x8a, 0x91, 0xa7, 0xd4,
	0xec, 0x7d, 0xd8, 0xb2, 0x45, 0x64, 0x5a, 0x33, 0x54, 0xbc, 0x29, 0xca, 0xe6, 0x26, 0x7d, 0xc8,
	0x1a, 0xca, 0x76, 0xa1, 0x76, 0xea, 0x78, 0x67, 0x22, 0x0c, 0x42, 0xc7, 0x8b, 0x48, 0xb2, 0x2b,
	0x3c, 0x0b, 0xa1, 0x34, 0x9e, 0xba, 0xa6, 0xc4, 0x6f, 0xd3, 0xb7, 0xc8, 0xbd, 0xb4, 0xd9, 0xdb,
	0x00, 0x67, 0x41, 0x6c, 0x9c, 0x9a, 0x73, 0xc7, 0x5d, 0x24, 0x4f, 0xc8, 0xea, 0x59, 0x10, 0x7f,
	0x4e, 0x00, 0x0e, 0x3d, 0x0b, 0xcd, 0x60, 0xe6, 0x58, 0x32, 0x79, 0x2b, 0x2d, 0x6d, 0xf6, 0x0e,
	0xc0, 0xcc, 0x8f, 0x2e, 0xfd, 0xd0, 0x76, 0xbc, 0x33, 0xba, 0x8f, 0x2a, 0x3c, 0x83, 0xa0, 0xea,
	0x3a, 0x5e, 0x24, 0x42, 0xcf, 0x74, 0x0d, 0xdb, 0x91, 0x81, 0x6b, 0x2e, 0xe8, 0xf5, 0x59, 0xe1,
	0xdb, 0x29, 0xde, 0x55, 0x30, 0x52, 0xb9, 0xb1, 0xe5, 0xd8, 0xd2, 0x15, 0x22, 0xa0, 0x4b, 0xb0,
	0xc2, 0x33, 0x48, 0x7a, 0x3f, 0xa6, 0xca, 0xae, 0x0c, 0x44, 0x03, 0xff, 0x52, 0x84, 0x7a, 0x49,
	0xa1, 0x64, 0xa0, 0xfe, 0xc9, 0xc8, 0x47, 0xd9, 0xa4, 0x32, 0xb4, 0xca, 0x53, 0x13, 0x4f, 0x35,
	0x12, 0xae, 0x08, 0x66, 0xbe, 0xb7, 0x48, 0xaa, 0xda, 0x15, 0xc0, 0x1e, 0x42, 0xe9, 0x52, 0x4c,
	0x2d, 0x73, 0xae, 0x57, 0x69, 0xfe, 0xc4, 0xc2, 0x2d, 0x88, 0xfc, 0xd8, 0x9a, 0x05, 0xa6, 0x4d,
	0xf5, 0x43, 0x85, 0x2f, 0x6d, 0xdc, 0x7b, 0x6a, 0x4b, 0x2b, 0x14, 0xc2, 0x23, 0xed, 0xaf, 0xf0,
	0x2c, 0xc4, 0x7e, 0x97, 0x03, 0x76, 0xe1, 0xd8, 0xc2, 0x37, 0x4c, 0xcb, 0x12, 0xae, 0x08, 0xd5,
	0x53, 0xb9, 0x46, 0x95, 0xce, 0xe4, 0x47, 0x88, 0x9b, 0x13, 0x24, 0x6f, 0x65, 0xb8, 0xf9, 0xce,
	0xc5, 0x3a, 0xd4, 0x98, 0x43, 0x39, 0x89, 0x2f, 0x12, 0xa6, 0x16, 0xe7, 0xfd, 0x1e, 0x5f, 0x13,
	0xa6, 0x04, 0x6c, 0x4d, 0x30, 0x37, 0x33, 0xbd, 0x26, 0x87, 0xc3, 0x76, 0x7f, 0xd0, 0x53, 0x4a,
	0x9d, 0x82, 0x27, 0x3d, 0xde, 0xff, 0x66, 0x78, 0xa4, 0xd4, 0x21, 0x05, 0xc7, 0x23, 0xde, 0x3f,
	0x9a, 0x68, 0x1b, 0x8d, 0xbf, 0x15, 0x60, 0xe7, 0xda, 0x77, 0xb1, 0x77, 0xe0, 0xc9, 0x49, 0xbf,
	0xdb, 0x1b, 0x1a, 0xad, 0x4e, 0xa7, 0x37, 0xe8, 0x71, 0xd2, 0x8c, 0xcc, 0x47, 0x3c, 0x85, 0x47,
	0x37, 0xf8, 0x0f, 0x9a, 0x1f, 0x7f, 0xa4, 0xe5, 0xd8, 0xbb, 0xf0, 0xf4, 0x06, 0x67, 0xef, 0xa8,
	0xa3, 0x3a, 0xe4, 0x51, 0xeb, 0x6f, 0xe8, 0x70, 0x32, 0xfa, 0x44, 0x2b, 0xbc, 0x66, 0x66, 0x1c,
	0x8c, 0xfe, 0x8d, 0xd7, 0x8e, 0xfd, 0x54, 0x2b, 0xfe, 0xe0, 0xd8, 0x4f, 0xb5, 0x12, 0x7b, 0x06,
	0xfa, 0xcd, 0x63, 0x8d, 0xa6, 0x56, 0x66, 0xbb, 0xf0, 0xec, 0xf5, 0xa3, 0x8d, 0xa6, 0x56, 0x79,
	0xfd, 0xaa, 0x5f, 0x68, 0xd5, 0x1f, 0x5e, 0xf5, 0x0b, 0x0d, 0x5e, 0x33, 0xfa, 0xf0, 0xe5, 0xe8,
	0x0b, 0xad, 0xf6, 0x03, 0xa3, 0xa9, 0xc3, 0x66, 0xe3, 0xdf, 0x45, 0xa8, 0x65, 0xaa, 0x35, 0x7c,
	0x3f, 0x9b, 0xb1, 0xed, 0xf8, 0x86, 0x7a, 0xf8, 0x95, 0x54, 0x1e, 0x12, 0xd4, 0xa6, 0xd7, 0xdf,
	0x53, 0xa8, 0xa6, 0x1d, 0xbe, 0x4f, 0x74, 0xb1, 0x92, 0xb8, 0xbf, 0x67, 0x4d, 0x78, 0xa0, 0x9c,
	0xae, 0xef, 0x07, 0x53, 0xd3, 0x3a, 0x37, 0x6c, 0xdf, 0x3b, 0x73, 0x05, 0x25, 0x6d, 0x85, 0xdf,
	0x23, 0xe7, 0x20, 0xf1, 0x75, 0xc9, 0x85, 0x29, 0xb9, 0xfa, 0xb1, 0xb8, 0xa8, 0x84, 0x76, 0x09,
	0xd0, 0x5b, 0x27, 0x35, 0xd2, 0x02, 0xfe, 0x0d, 0xde, 0x3a, 0x99, 0x25, 0xae, 0x7e, 0x5b, 0xa6,
	0xb2, 0xb7, 0x6e, 0x65, 0x4d, 0x94, 0x21, 0xcb, 0xf7, 0xec, 0xd8, 0x8a, 0x9c, 0x0b, 0x91, 0xfc,
	0xea, 0x93, 0x41, 0x50, 0x22, 0x66, 0xb1, 0x6d, 0xbb, 0x8b, 0x54, 0x22, 0x94, 0xc5, 0x18, 0x6c,
	0xcc, 0x9d, 0xb9, 0x9f, 0xa8, 0x1b, 0xb5, 0x51, 0x86, 0x82, 0xe8, 0xb7, 0x41, 0xe8, 0x37, 0x13,
	0xdd, 0x4e, 0x4d, 0x94, 0x2d, 0xfa, 0xb5, 0x9c, 0x24, 0xa8, 0xc2, 0x95, 0x81, 0xdc, 0x32, 0x5a,
	0xb8, 0xb1, 0x24, 0x11, 0xae, 0xf0, 0xc4, 0xa2, 0x1d, 0x32, 0xe7, 0x22, 0x34, 0x71, 0xcb, 0xeb,
	0xc9, 0x0e, 0xa5, 0x00, 0x8a, 0xd3, 0xa5, 0x73, 0xea, 0x58, 0xc2, 0x75, 0x49, 0x9f, 0x2b, 0x7c,
	0x69, 0x37, 0xfe, 0x90, 0x87, 0xfa, 0x95, 0xe5, 0x62, 0x9c, 0x77, 0x0e, 0x5a, 0x87, 0xbd, 0x41,
	0x6f, 0x78, 0xb4, 0x5e, 0x23, 0x3c, 0x86, 0x07, 0x6b, 0xbe, 0xf6, 0xc4, 0x38, 0xa0, 0x4a, 0x01,
	0x2b, 0xc2, 0xab, 0xae, 0xee, 0x48, 0x65, 0xdc, 0x35, 0xd8, 0x38, 0xe8, 0x1e, 0xf6, 0xb5, 0x02,
	0x15, 0x97, 0x57, 0x7d, 0x27, 0x5f, 0xb4, 0xb4, 0x0d, 0x2c, 0xd5, 0xd6, 0x70, 0x1a, 0x50, 0x64,
	0x6f, 0xc3, 0xe3, 0xeb, 0xd3, 0xb7, 0x07, 0x3d, 0xfa, 0x84, 0x12, 0x86, 0xf2, 0x75, 0x77, 0xab,
	0xd9, 0x1d, 0x19, 0xe3, 0xfe, 0xd1, 0x2b, 0xad, 0x7c, 0xc3, 0xc7, 0xb4, 0x27, 0xc6, 0xa8, 0xd7,
	0xe3, 0x5a, 0xa5, 0xf1, 0x9f, 0x0d, 0xd8, 0xb9, 0x56, 0x61, 0x63, 0x2c, 0x5b, 0x33, 0xd3, 0x97,
	0x86, 0x1d, 0x47, 0x69, 0x2c, 0x13, 0xd0, 0x8d, 0x23, 0xf6, 0x1c, 0xea, 0xca, 0xe9, 0x39, 0x67,
	0xb3, 0xc8, 0x5d, 0x24, 0x3b, 0xbf, 0x49, 0xe0, 0x91, 0xc2, 0x28, 0x5c, 0x28, 0x00, 0xe9, 0x41,
	0x91, 0x86, 0xcb, 0x12, 0x61, 0x33, 0x00, 0x7c, 0xd9, 0xca, 0xc0, 0x0c, 0x25, 0x66, 0x01, 0x86,
	0x6e, 0xff, 0x8e, 0x0f, 0x03, 0x7c, 0xdc, 0x8e, 0x89, 0x90, 0x57, 0xad, 0x48, 0xaa, 0x26, 0x26,
	0xee, 0xcc, 0xf4, 0xce, 0xfc, 0x38, 0x32, 0xcc, 0x20, 0x48, 0xa2, 0x13, 0x12, 0xa8, 0x15, 0x04,
	0xf8, 0xf6, 0x9c, 0x0b, 0xa1, 0xbc, 0xea, 0x12, 0x2b, 0xa3, 0x8d, 0xae, 0xe7, 0x50, 0x0f, 0x05,
	0x3d, 0x62, 0x16, 0x06, 0x3e, 0x3a, 0x92, 0x28, 0xde, 0x4c, 0x41, 0xfa, 0xbf, 0xca, 0x7b, 0xb0,
	0x45, 0x8f, 0x1d, 0xca, 0xe1, 0xef, 0xd4, 0x4f, 0x7e, 0xf4, 0xf6, 0x40, 0xb4, 0x95, 0x82, 0xcb,
	0x6e, 0x33, 0x7b, 0xee, 0x50, 0xd7, 0x24, 0xc6, 0xa9, 0xdb, 0x41, 0x0a, 0xe2, 0x94, 0xd4, 0x2d,
	0x96, 0x53, 0xd5, 0x4b, 0x85, 0xee, 0x26, 0x82, 0xc7, 0x09, 0x86, 0xe5, 0x43, 0xda, 0x89, 0xca,
	0x18, 0x2c, 0x32, 0x94, 0x42, 0x6c, 0x27, 0xfd, 0x52, 0x18, 0x8b, 0x98, 0x58, 0x4e, 0x0d, 0x5b,
	0x44, 0xc2, 0x8a, 0x12, 0xd9, 0xaa, 0xc6, 0x72, 0xda, 0x25, 0x80, 0x3d, 0x82, 0x72, 0x2c, 0x85,
	0xe1, 0x3a, 0x76, 0x92, 0x8a, 0xa5, 0x58, 0x8a, 0x81, 0x63, 0x37, 0xbe, 0x86, 0xea, 0x72, 0x3b,
	0x29, 0x64, 0x27, 0x63, 0x63, 0x3c, 0x6a, 0xf1, 0x2b, 0x55, 0xab, 0x06, 0x9b, 0x19, 0xbc, 0xa9,
	0x2a, 0xe7, 0x0c, 0xf2, 0xa1, 0x96, 0x5f, 0x43, 0x5e, 0x68, 0x85, 0x46, 0x13, 0x2a, 0xe9, 0xbf,
	0x20, 0xf0, 0x1d, 0x7f, 0x2e, 0x16, 0xc9, 0x0f, 0x71, 0xd8, 0x44, 0x09, 0xb8, 0x40, 0x57, 0xfa,
	0xdb, 0x1a, 0x19, 0xed, 0xda, 0x37, 0xd5, 0xe5, 0xc9, 0xff, 0x2f, 0x00, 0x00, 0xff, 0xff, 0xda,
	0xd5, 0x4b, 0xed, 0x4f, 0x1c, 0x00, 0x00,
}
