// Copyright (c) 2023 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package main

import (
	"flag"
	"fmt"
	"path"
	"strings"

	"go.chromium.org/luci/common/errors"
)

type Lastchange struct{}

type lastchangeArgs struct {
	versionMacro     string
	output           string
	header           string
	revision         string
	revisionIDOnly   bool
	revisionIDPrefix string
	sourceDir        string
	filter           string
}

const lastchangeDefaultFilter = "^Change-Id:"

func (l Lastchange) parseCLI(cwd string, args []string) (match bool, ret lastchangeArgs, err error) {
	idx := 0
	prog := args[idx]
	if knownPythonNames.Has(prog) {
		idx = 1
		prog = args[idx]
	}
	if !strings.HasSuffix(prog, "lastchange.py") {
		// no match
		return
	}
	match = true
	LEAKY("lastchange.py CLI argument parser")

	fs := flag.NewFlagSet("lastchange", flag.ContinueOnError)
	shortLongStringVar(fs, &ret.output, "o", "output")

	shortLongStringVar(fs, &ret.versionMacro, "m", "version-macro")
	fs.StringVar(&ret.header, "header", "", "")
	fs.StringVar(&ret.revision, "revision", "", "")
	fs.BoolVar(&ret.revisionIDOnly, "revision-id-only", false, "")
	shortLongStringVar(fs, &ret.sourceDir, "s", "source-dir")
	fs.StringVar(&ret.filter, "filter", lastchangeDefaultFilter, "")
	fs.StringVar(&ret.revisionIDPrefix, "revision-id-prefix", "", "")

	// ignored
	fs.String("merge-base-ref", "", "")
	fs.Bool("print-only", false, "")

	err = fs.Parse(args[idx+1:])
	if err == nil && len(fs.Args()) > 0 {
		// NOTE: it is possible in lastchange.py to have the first extra arg mean
		// '--output', but I didn't see any uses like that, so just making it an
		// error here.
		err = errors.Reason("lastchange with extra args %q", fs.Args()).Err()
	}

	// this is weird, but lastchange.py uses it's own path if sourceDir is
	// unspecified.
	if ret.sourceDir == "" {
		ret.sourceDir = path.Dir(path.Join(cwd, prog))
	}

	return
}

func (l Lastchange) getHeaderContents(path, macro, revision string) string {
	LEAKY("Lastchange.getHeaderContents hard codes 'src/' prefix")
	guard := path
	if pfx := "src/"; strings.HasPrefix(guard, pfx) {
		guard = guard[len(pfx):]
	}
	guard = strings.NewReplacer(
		"/", "_",
		".", "_",
	).Replace(strings.ToUpper(guard)) + "_"

	content := strings.Builder{}
	fmt.Fprintln(&content, "/* Generated by lastchange.py, do not edit.*/")
	fmt.Fprintln(&content)
	fmt.Fprintln(&content, "#ifndef", guard)
	fmt.Fprintln(&content, "#define", guard)
	fmt.Fprintln(&content)
	fmt.Fprintf(&content, "#define %s %q\n", macro, revision)
	fmt.Fprintln(&content)
	fmt.Fprintln(&content, "#endif  //", guard)

	return content.String()
}

func (l Lastchange) HandleHook(oracle *Oracle, cwd string, action *GclientHook) (handled bool, err error) {
	var args lastchangeArgs
	handled, args, err = l.parseCLI(cwd, action.Action)
	if !handled {
		return
	}

	if args.revisionIDPrefix != "" {
		TODO("lastchange.py --revision-id-prefix")
		return
	}

	commit, footers, err := oracle.GetCommitObject(path.Join(cwd, args.sourceDir), args.filter)
	if err != nil {
		return
	}

	revision := commit.Hash.String()
	if !args.revisionIDOnly {
		if cpos, ok := footers["Cr-Commit-Position"]; ok {
			if len(cpos) != 1 {
				err = errors.Reason("got more than one Cr-Commit-Position value: %v", cpos).Err()
				return
			}
			revision = fmt.Sprintf("%s-%s", revision, cpos[0])
		}
	}
	if args.revisionIDPrefix != "" {
		revision = args.revisionIDPrefix + revision
	}

	var pickedAnyOutput bool
	if args.output != "" {
		pickedAnyOutput = true
		dest := path.Join(cwd, args.output)
		content := strings.Builder{}
		fmt.Fprintf(&content, "LASTCHANGE=%s\n", revision)
		fmt.Fprintf(&content, "LASTCHANGE_YEAR=%d\n", commit.Committer.When.Year())

		oracle.PinRawFile(dest, content.String(), "lastchange.py hook - "+action.Name)
		oracle.PinRawFile(
			dest+".committime",
			fmt.Sprintf("%d\n", commit.Committer.When.Unix()),
			"lastchange.py hook - "+action.Name)
	}
	if args.header != "" {
		pickedAnyOutput = true
		dest := path.Join(cwd, args.header)
		oracle.PinRawFile(
			dest,
			l.getHeaderContents(dest, args.versionMacro, revision),
			"lastchange.py hook - "+action.Name)
	}
	if args.revision != "" {
		pickedAnyOutput = true
		dest := path.Join(cwd, args.revision)
		oracle.PinRawFile(
			dest,
			revision,
			"lastchange.py hook - "+action.Name)
	}

	if !pickedAnyOutput {
		TODO("lastchange.py", action.Name, revision)
	}
	return
}
