// Copyright 2024 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

//go:build ignore

package main

import (
	"bufio"
	"bytes"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"slices"
	"sync"
	"time"

	"golang.org/x/sync/errgroup"
)

func main() {
	goroot := os.Getenv("GOROOT")
	if goroot == "" {
		log.Fatal("GOROOT is empty, but it is required")
	}
	if runtime.GOMAXPROCS(-1) < 16 {
		log.Fatal("please run on a machine with at least 16 cores")
	}
	shards := runtime.GOMAXPROCS(-1) / 16

	// Run `go tool dist test -list` to list all tests.
	tests, err := goDistTestList(goroot, false)
	if err != nil {
		log.Fatal(err)
	}

	// Measure test run times.
	var eg errgroup.Group
	eg.SetLimit(shards)

	var testTimesMu sync.Mutex
	testTimes := make(map[string]time.Duration)
	for _, testName := range tests {
		eg.Go(func() error {
			// Run the test.
			dt, err := goDistTestTime(goroot, testName, false)
			if err != nil {
				fmt.Printf("FAIL\t%s\t(%v)\n", testName, err)
				return err
			}
			fmt.Printf("ok\t%s\t%.3fs\n", testName, dt.Seconds())

			// Store the result.
			testTimesMu.Lock()
			defer testTimesMu.Unlock()
			testTimes[testName] = dt

			return nil
		})
	}

	// Do the same for any race-mode exclusive tests.
	raceTests, err := goDistTestList(goroot, true)
	if err != nil {
		log.Fatal(err)
	}
	for _, testName := range raceTests {
		if _, ok := testTimes[testName]; ok {
			// Don't measure tests we've already measured again.
			continue
		}
		eg.Go(func() error {
			// Run the test.
			dt, err := goDistTestTime(goroot, testName, true)
			if err != nil {
				fmt.Printf("FAIL\t%s\t(%v)\n", testName, err)
				return err
			}
			fmt.Printf("ok\t%s\t%.3fs\n", testName, dt.Seconds())

			// Store the result.
			testTimesMu.Lock()
			defer testTimesMu.Unlock()
			testTimes[testName] = dt

			return nil
		})
	}

	// Wait for all tests to complete.
	if err := eg.Wait(); err != nil {
		log.Fatal(err)
	}

	// Generate a Go file.
	weightsFile, err := generateWeightsFile(testTimes)
	if err != nil {
		log.Fatal(err)
	}
	// Format it.
	if err := exec.Command("gofmt", "-w", "-s", weightsFile).Run(); err != nil {
		log.Fatal(err)
	}
}

func generateWeightsFile(testTimes map[string]time.Duration) (string, error) {
	// Get a sorted list of all the tests.
	allTests := make([]string, 0, len(testTimes))
	for testName := range testTimes {
		allTests = append(allTests, testName)
	}
	slices.Sort(allTests)

	fname := "raw.go"
	f, err := os.Create(fname)
	if err != nil {
		return "", fmt.Errorf("creating file %q: %w", os.Args[1], err)
	}
	defer f.Close()

	if _, err := fmt.Fprintln(f, header); err != nil {
		return "", err
	}
	if _, err := fmt.Fprintln(f, "var goDistTestWeights = map[string]int{"); err != nil {
		return "", err
	}
	for _, testName := range allTests {
		weight := int(testTimes[testName].Seconds())
		if weight <= 1 {
			// Unnamed tests have an implicit weight of 1.
			continue
		}
		if _, err := fmt.Fprintf(f, "\t%q: %d,\n", testName, weight); err != nil {
			return "", err
		}
	}
	if _, err := fmt.Fprintln(f, "}"); err != nil {
		return "", err
	}
	return fname, nil
}

const header = `// Copyright 2024 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Code generated by "go run computeweights.go". DO NOT EDIT.

package testweights
`

func goDistTestList(goroot string, race bool) ([]string, error) {
	testListCmd := exec.Command(filepath.Join(goroot, "bin", "go"), "tool", "dist", "test", "-list")
	if race {
		testListCmd.Args = append(testListCmd.Args, "-race")
	}
	// Always run in longtest mode to make sure all tests are visible.
	testListCmd.Env = append(os.Environ(), "GO_TEST_SHORT=0")

	// Run the command.
	output, err := testListCmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to run %q: %v", testListCmd.String(), err)
	}

	// Parse the outputâ€”each line is a test name.
	var tests []string
	scanner := bufio.NewScanner(bytes.NewReader(output))
	for scanner.Scan() {
		tests = append(tests, scanner.Text())
	}
	return tests, nil
}

func goDistTestTime(goroot, testName string, race bool) (time.Duration, error) {
	// Try to run three times, in case of flakiness.
	var dt time.Duration
	var err error
	for i := 0; i < 3; i++ {
		testRunCmd := exec.Command(filepath.Join(goroot, "bin", "go"), "tool", "dist", "test")
		if race {
			testRunCmd.Args = append(testRunCmd.Args, "-race")
		}
		testRunCmd.Args = append(testRunCmd.Args, testName)

		// Always run in longtest mode to make sure all tests are visible.
		testRunCmd.Env = append(os.Environ(), "GOMAXPROCS=16", "GO_TEST_SHORT=0")

		// Run the command, and time it.
		start := time.Now()
		if err := testRunCmd.Run(); err != nil {
			err = fmt.Errorf("failed to run %q: %v", testRunCmd.String(), err)
			continue
		}
		dt = time.Since(start)
		break
	}
	return dt, err
}
