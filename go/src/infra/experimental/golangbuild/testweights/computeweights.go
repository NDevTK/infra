// Copyright 2024 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

//go:build ignore

package main

import (
	"bufio"
	"bytes"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"slices"
	"sync"
	"time"

	"golang.org/x/sync/errgroup"
)

func main() {
	if _, err := exec.LookPath("go"); err != nil {
		log.Fatal("'go' command is not found, but it is required:", err)
	}
	if runtime.GOMAXPROCS(-1) < 16 {
		log.Fatal("please run on a machine with at least 16 cores")
	}
	shards := runtime.GOMAXPROCS(-1) / 16

	// Run `go tool dist test -list` to list all tests.
	tests, err := goDistTestList(false)
	if err != nil {
		log.Fatal(err)
	}

	// Measure test run times.
	var eg errgroup.Group
	eg.SetLimit(shards)

	var testTimesMu sync.Mutex
	testTimes := make(map[string]time.Duration)
	for _, testName := range tests {
		testName := testName
		eg.Go(func() error {
			// Run the test.
			dt, err := goDistTestTime(testName, false)
			if err != nil {
				fmt.Printf("FAIL\t%s\t(%v)\n", testName, err)
				return err
			}
			fmt.Printf("ok\t%s\t%.3fs\n", testName, dt.Seconds())

			// Store the result.
			testTimesMu.Lock()
			defer testTimesMu.Unlock()
			testTimes[testName] = dt

			return nil
		})
	}

	// Do the same for any race-mode exclusive tests.
	raceTests, err := goDistTestList(true)
	if err != nil {
		log.Fatal(err)
	}
	for _, testName := range raceTests {
		testName := testName
		if _, ok := testTimes[testName]; ok {
			// Don't measure tests we've already measured again.
			continue
		}
		eg.Go(func() error {
			// Run the test.
			dt, err := goDistTestTime(testName, true)
			if err != nil {
				fmt.Printf("FAIL\t%s\t(%v)\n", testName, err)
				return err
			}
			fmt.Printf("ok\t%s\t%.3fs\n", testName, dt.Seconds())

			// Store the result.
			testTimesMu.Lock()
			defer testTimesMu.Unlock()
			testTimes[testName] = dt

			return nil
		})
	}

	// Wait for all tests to complete.
	if err := eg.Wait(); err != nil {
		log.Fatal(err)
	}

	// Generate a Go file.
	contents, err := generateWeightsFile(testTimes)
	if err != nil {
		log.Fatal(err)
	}
	// Format it.
	formattedContents, err := format.Source(contents)
	if err != nil {
		log.Printf("generated file:\n%s", contents)
		log.Fatalf("formatting generated file: %v", err)
	}
	// Write it.
	if err := os.WriteFile("raw.go", formattedContents, 0o644); err != nil {
		log.Fatal(err)
	}
}

func generateWeightsFile(testTimes map[string]time.Duration) []byte {
	var buf bytes.Buffer

	// Get a sorted list of all the tests.
	allTests := make([]string, 0, len(testTimes))
	for testName := range testTimes {
		allTests = append(allTests, testName)
	}
	slices.Sort(allTests)

	fmt.Fprintln(&buf, header)
	fmt.Fprintln(&buf, "var goDistTestWeights = map[string]int{")
	for _, testName := range allTests {
		weight := int(testTimes[testName].Seconds())
		if weight <= 1 {
			// Unnamed tests have an implicit weight of 1.
			continue
		}
		fmt.Fprintf(&buf, "\t%q: %d,\n", testName, weight)
	}
	fmt.Fprintln(&buf, "}")
	return buf.Bytes()
}

const header = `// Copyright 2024 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Code generated by "go run computeweights.go". DO NOT EDIT.

package testweights
`

func goDistTestList(race bool) ([]string, error) {
	testListCmd := exec.Command("go", "tool", "dist", "test", "-list")
	if race {
		testListCmd.Args = append(testListCmd.Args, "-race")
	}
	// Always run in longtest mode to make sure all tests are visible.
	testListCmd.Env = append(os.Environ(), "GO_TEST_SHORT=0")

	// Run the command.
	output, err := testListCmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to run %q: %v", testListCmd.String(), err)
	}

	// Parse the outputâ€”each line is a test name.
	var tests []string
	scanner := bufio.NewScanner(bytes.NewReader(output))
	for scanner.Scan() {
		tests = append(tests, scanner.Text())
	}
	return tests, nil
}

func goDistTestTime(testName string, race bool) (time.Duration, error) {
	// Try to run three times, in case of flakiness.
	var dt time.Duration
	var testRunErr error
	for i := 0; i < 3; i++ {
		testRunCmd := exec.Command("go", "tool", "dist", "test")
		if race {
			testRunCmd.Args = append(testRunCmd.Args, "-race")
		}
		testRunCmd.Args = append(testRunCmd.Args, testName)

		// Always run in longtest mode to make sure all tests are visible.
		// Also, always run with GOMAXPROCS=16. This is important for two reasons.
		// One, there are some tests that are only enabled if GOMAXPROCS is high
		// enough, so we don't want to miss them.
		// And two, most of our builder machines have 16 cores as of this writing,
		// so this will give slightly more accurate timings. It will still be slightly
		// wrong for other platforms, but we don't generally shard on those platforms.
		testRunCmd.Env = append(os.Environ(), "GOMAXPROCS=16", "GO_TEST_SHORT=0")

		// Run the command, and time it.
		start := time.Now()
		if err := testRunCmd.Run(); err != nil {
			testRunErr = fmt.Errorf("failed to run %q: %v", testRunCmd.String(), err)
			continue
		}
		dt = time.Since(start)
		break
	}
	return dt, testRunError
}
