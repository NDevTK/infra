<link rel="import" href="../bower_components/polymer/polymer.html">

<link rel="import" href="../bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="../bower_components/iron-collapse/iron-collapse.html">
<link rel="import" href="../bower_components/paper-spinner/paper-spinner.html">
<link rel="import" href="../bower_components/paper-icon-button/paper-icon-button.html">

<dom-module id="som-bug-queue">
  <template>
    <style>
      #main {
        background: white;
      }
      #error {
        color: red;
      }
      #error,
      #loadingBugs,
      #noBugs {
        padding: 0.3em 0.5em;
        margin: 0 1em;
      }
      h2 {
        font-size: 22px;
        font-weight: bold;
        padding: 0.5em 0.5em 0.2em;
        margin: 1em 0.5em 0.5em;
        background-color: #eee;
        border-bottom: 1px solid #ddd;
      }
      .bug {
        padding: 0.3em 0.5em;
        line-height: 150%;
        border-bottom: 1px solid #ddd;
        margin: 0 1em;
      }
      .bug-label {
        font-size: 0.8em;
        text-decoration: none;
        color: #008000;
      }
      .bug-label:hover,
      .summary:hover {
        text-decoration: underline;
      }
      .summary {
        font-weight: bold;
        color: #222;
        text-decoration: none;
      }
      .summary-box {
        text-overflow: ellipsis;
        max-width: 90%;
      }
      .collapse {
        cursor: pointer;
      }
    </style>
    <iron-ajax
        id="bugQueueAjax"
        url="/api/v1/bugqueue/[[bugQueueLabel]]"
        handle-as="json"
        last-error="{{_bugQueueJsonError}}"
        last-response="{{_bugQueueJson}}"
        debounce-duration="300"></iron-ajax>
    <iron-ajax
        id="assignedBugsAjax"
        url="/api/v1/bugqueue/[[bugQueueLabel]]/owned"
        handle-as="json"
        last-error="{{_assignedBugsJsonError}}"
        last-response="{{_assignedBugsJson}}"
        debounce-duration="300"></iron-ajax>
    <iron-ajax
        id="issueListAjax"
        url="/api/v1/bugqueue/issue/bulk_issue"
        body="[[_bugsToFetch]]"
        content-type="application/json"
        method="POST"
        handle-as="json"
        last-error="{{_issueListError}}"
        last-response="{{_issueListResponse}}"
        debounce-duration="1000"></iron-ajax>
    <div id="main" hidden$="[[_hideBugQueue]]">
      <h2 hidden$="[[_isTrooperQueue]]">[[treeDisplayName]] Bug Queue (<a href="https://sites.google.com/a/chromium.org/dev/developers/tree-sheriffs/sheriffing-bug-queues" target="_blank">Help?</a>)</h2>
      <h2 hidden$="[[!_isTrooperQueue]]">Trooper Queue (<a href="http://go/trooper-queue" target="_blank">View in Monorail</a>)</h2>
      <div id="error" hidden$="[[_haveNoErrors(_bugQueueJsonError)]]">
        Error fetching bug queue: [[_bugQueueJsonError.error]]
      </div>
      <div id="error" hidden$="[[_haveNoErrors(_assignedBugsJsonError)]]">
        Error fetching assigned bugs: [[_assignedBugsJsonError.error]]
      </div>
      <div id="loadingBugs" hidden$="[[!_showBugsLoading(_bugsLoaded, _bugQueueJsonError)]]"><paper-spinner active="[[!_bugsLoaded]]"></paper-spinner> Loading Bug Queue... </div>
      <div id="noBugs" hidden$="[[!_showNoBugs]]">No bugs in the queue!</div>
      <template is="dom-repeat" items="[[_sortBugs(bugs)]]" as="bug">
        <div class="bug">
          <div class="summary-box">
            <a href="http://crbug.com/[[bug.id]]" target="_blank" title="[[bug.summary]]" class="summary">[[bug.summary]]</a>
            <template is="dom-repeat" items="[[_filterBugLabels(bug.labels, bugQueueLabel)]]" as="label">
              <a href="https://bugs.chromium.org/p/chromium/issues/list?q=label:[[label]]"
                class="bug-label" target="_blank">[[label]]</a>
            </template>
          </div>
          <a href="http://crbug.com/[[bug.id]]" target="_blank">Bug [[bug.id]]</a>
          ([[bug.status]]<template is="dom-if" if="[[bug.owner.name]]">,
          [[bug.owner.name]]</template>)
          <template is="dom-if" if="[[_hasPriority(bug)]]">
            (Pri-[[_computePriority(bug)]])
          </template>
          <template is="dom-if" if="[[bug.alerts]]">
            <div class="layout vertical">
              <div class="layout horizontal">
                Alerts tied to this bug:
                <div class="collapse layout horizontal center" on-tap="_toggleCollapse">
                  <iron-icon icon="[[_iconName]]"></iron-icon>
                </div>
              </div>
              <!--<iron-collapse id$="[[_collapseIDForBug(bug)]]" no-animation> -->
                <ul class="layout vertical">
                  <template is="dom-repeat" items="[[_addBug(bug, bug.alerts)]]" as="alert">
                    <li>
                      [[alert.title]]
                      <paper-icon-button icon="close" title="Remove" id="remove[[index]]" on-tap="_removeBug"></paper-icon-button>
                    </li>
                  </template>
                </ul>
            </div>
          </template>
      </template>
    </div>
  </template>
  <script>
  (function() {
    'use strict';

    Polymer({
      is: 'som-bug-queue',

      properties: {
        alertsWithBugs: {
          type: Object,
          value: function() { return {}; },
          notify: true,
          observer: '_alertsWithBugsChange',
        },
        bugQueueLabel: {
          type: String,
          observer: '_changeBugQueueLabel',
        },
        _assignedBugsJson: {
          type: Object,
          value: null,
        },
        _assignedBugsJsonError: {
          type: Object,
          value: null,
        },
        bugs: {
          type: Array,
          notify: true,
          computed: '_computeBugs(_bugQueueJson.*, alertsWithBugs, _issueListResponse, _assignedBugsJson)',
        },
        _bugsToFetch: {
          type: Array,
          computed: '_computeBugsToFetch(alertsWithBugs)',
        },
        _bugQueueJson: {
          type: Object,
          value: function() { return {}; },
        },
        _bugQueueJsonError: {
          type: Object,
          value: null,
        },
        _bugsLoaded: {
          type: Boolean,
          value: false,
        },
        _hideBugQueue: {
          type:Boolean,
          value: true,
          computed: '_computeHideBugQueue(bugQueueLabel)',
        },
        _iconName: {
          type: String,
          value: 'icons:unfold-more'
        },
        _isTrooperQueue: {
          type: Boolean,
          value: false,
          computed: '_computeIsTrooperQueue(bugQueueLabel)',
        },
        _issueListResponse: {
          type: Array,
          value: function() { return {}; },
        },
        _showNoBugs: {
          type: Boolean,
          value: false,
          computed: '_computeShowNoBugs(bugs, _bugsLoaded, _bugQueueJsonError)',
        },
      },

      _collapseIDForBug: function(bug){
        return "collapse" + bug;
      },

      _addBug: function(bug, alerts) {
        alerts.forEach((alr) => {
          alr['linkedBug'] = bug;
        });
        return alerts;
      },

      _alertsWithBugsChange: function(alertsWithBugs) {
        this.$.issueListAjax.generateRequest();
      },

      refresh: function() {
        if (this._hideBugQueue) {
          return;
        }

        let promises = [this.$.bugQueueAjax.generateRequest().completes];
        if (this._isTrooperQueue) {
          promises.push(this.$.assignedBugsAjax.generateRequest().completes);
        }

        Promise.all(promises).then((reponse) => {
          this._bugsLoaded = true;
        });
      },

      _computeBugsToFetch: function(alertsWithBugs) {
        return Object.keys(alertsWithBugs).map((bug) => {
          return parseInt(bug, 10);
        });
      },

      isEmpty: function(obj) {
        if (obj == null || obj == undefined) {
          return false;
        }

        return Object.keys(obj).length == 0;
      },

      _computeBugs: function(bugQueueJson, alertsWithBugs, issueListResponse, assignedBugsJson) {
        bugQueueJson = bugQueueJson.base;

        let bugs = {};
        let items = (bugQueueJson && bugQueueJson.items) || [];
        items = items.concat(assignedBugsJson && assignedBugsJson.items || []);
        items.forEach((bug) => {
          bugs[bug.id] = bug;
        });

        if (!this.isEmpty(alertsWithBugs) && !this.isEmpty(issueListResponse)) {
          issueListResponse.forEach((bug) => {
            if (!bug) {
              return;
            }

            bugs[bug.id] = bug;
          });

          Object.keys(alertsWithBugs).forEach((bug) => {
            bug = parseInt(bug, 10);
            if (!bugs[bug]) {
              return;
            }

            bugs[bug].alerts = alertsWithBugs[bug];
          });
        }

        return Object.values(bugs);
      },

      _computeHideBugQueue: function(bugQueueLabel) {
        return false;
        // No loading or empty message is shown unless a bug queue exists.
        return !bugQueueLabel || bugQueueLabel === ''
          || bugQueueLabel === 'Performance-Sheriff-BotHealth';
      },

      _computeIsTrooperQueue: function(bugQueueLabel) {
        return bugQueueLabel === 'infra-troopers';
      },

      _computePriority: function(bug) {
        if (!bug || !bug.labels) {
          return '';
        }
        for (let i in bug.labels) {
          let match = bug.labels[i].match(/^Pri-(\d)$/);
          if (match) {
            let result = parseInt(match[1]);
            return result !== NaN ? result : '';
          }
        }
        return '';
      },

      _computeShowNoBugs: function(bugs, bugsLoaded, error) {
        // Show the "No bugs" message only when the queue is done loading
        return bugsLoaded && this._haveNoBugs(bugs) && this._haveNoErrors(error);
      },

      _changeBugQueueLabel: function() {
        if (this.bugQueueLabel == "") {
          return
        }

        this._bugQueueJson = null;
        this._bugQueueJsonError = null;

        this._assignedBugsJson = null;
        this._assignedBugsJsonError = null;

        this._bugsLoaded = false;

        this.refresh();
      },

      _filterBugLabels: function(labels, bugQueueLabel) {
        if (!labels) {
          return [];
        }
        return labels.filter((label) => {
          return label.toLowerCase() != bugQueueLabel.toLowerCase()
            && !label.match(/^Pri-(\d)$/);
        });
      },

      _hasPriority: function(bug) {
        return this._computePriority(bug) !== '';
      },

      _haveNoBugs: function(bugs) {
        return !bugs || bugs.length == 0;
      },

      _haveNoErrors: function(error) {
        return !error;
      },

      _showBugsLoading: function(bugsLoaded, error) {
        return !bugsLoaded && this._haveNoErrors(error);
      },

      _removeBug: function(evt) {
        this.fire('annotation-change', {
          type: 'remove',
          change: {
            'bugs': [new String(evt.model.alert.linkedBug.id)]
          },
          target: evt.model.alert.key,
        });
      },

      _sortBugs: function(bugs) {
        if (bugs) {
          // Sort bugs by priority.
          bugs.sort((a, b) => {
            let pA = this._computePriority(a);
            let pB = this._computePriority(b);
            if (pA === '' && pB === '') {
              return 0;
            } else if (pA === '') {
              // Put blank priority bugs after all other bugs.
              return 1;
            } else if (pB === '') {
              return -1;
            }
            return pA - pB;
          });
        }
        return bugs;
      },

      _toggleCollapse: function(evt) {
        debugger;
        let collapseElem = this.$$('#collapse');
        collapseElem.toggle();
        this._iconName = collapseElem.opened ? 'icons:unfold-less' :
            'icons:unfold-more';
        this._collapseMessage = collapseElem.opened ? 'less' : 'more';
      },
    });
  })();
  </script>
</dom-module>
