// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package bugclusters

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"regexp"

	"infra/appengine/weetbix/internal/analysis"
	"infra/appengine/weetbix/internal/bugs"
	"infra/appengine/weetbix/internal/bugs/monorail"
	"infra/appengine/weetbix/internal/clustering"
	"infra/appengine/weetbix/internal/clustering/algorithms"
	"infra/appengine/weetbix/internal/config"

	"go.chromium.org/luci/common/errors"
	"go.chromium.org/luci/common/logging"
	"go.chromium.org/luci/server/span"
)

// TODO (crbug.com/1243174): Currently analysis is hardcoded to only analyse
// one LUCI project, which is recorded here.
const analysisProject = "chromium"

// bugRe matches Weetbix bug names, of the form
// "{bug_system}/{bug_id}", for example, "monorail/chromium/123", where
// bug_system = "monorail and bug_id = "chromium/123". bug_id may be further
// parsed by bug managers for particular bug systems.
var bugRe = regexp.MustCompile(`^([a-z0-9\-_]+)/(.+)$`)

// ClusterClient is an interface for accessing cluster analysis.
type ClusterClient interface {
	// ReadImpactfulClusters reads analysis for clusters matching the
	// specified criteria.
	ReadImpactfulClusters(ctx context.Context, opts analysis.ImpactfulClusterReadOptions) ([]*analysis.ClusterSummary, error)
}

// BugManager implements bug creation and bug updates for a bug-tracking
// system. The BugManager determines bug content and priority given a
// cluster.
type BugManager interface {
	// Create creates a new bug for the given cluster, returning its name,
	// or any encountered error.
	Create(ctx context.Context, cluster *bugs.Cluster) (string, error)
	// Update updates the specified list of bugs.
	Update(ctx context.Context, bugs []*bugs.BugToUpdate) error
}

// BugUpdater performs updates to Monorail bugs and BugClusters to keep them
// in sync with clusters generated by analysis.
type BugUpdater struct {
	// project is the LUCI project to act on behalf of.
	project string
	// clusterClient provides access to cluster analysis.
	clusterClient ClusterClient
	// managers stores the manager responsible for updating bugs for each
	// bug tracking system (monorail, buganizer, etc.).
	managers map[string]BugManager
	// bugFilingThreshold is the threshold at which bugs should be filed.
	bugFilingThreshold *config.ImpactThreshold
	// MaxBugsFiledPerRun is the maximum number of bugs to file each time
	// BugUpdater runs. This throttles the rate of changes to monorail.
	MaxBugsFiledPerRun int
}

// NewBugUpdater initialises a new BugUpdater. The specified impact thresholds are used
// when determining whether to a file a bug.
func NewBugUpdater(project string, mgrs map[string]BugManager, cc ClusterClient, bugFilingThreshold *config.ImpactThreshold) *BugUpdater {
	return &BugUpdater{
		project:            project,
		managers:           mgrs,
		clusterClient:      cc,
		bugFilingThreshold: bugFilingThreshold,
		MaxBugsFiledPerRun: 1, // Default value.
	}
}

const rulesAlgorithmPrefix = "rules-"
const rulesAlgorithmUsing = "rules-v1"

// Run updates files/updates bugs to match high-impact clusters as
// identified by analysis. Each bug has a corresponding failure association
// rule.
func (b *BugUpdater) Run(ctx context.Context) error {
	ruleByID, err := b.readActiveFailureAssociationRules(ctx)
	if err != nil {
		return errors.Annotate(err, "read active failure association rules").Err()
	}
	// We want to read analysis for three categories of clusters:
	// - Bug Clusters: they will have analysis on the failures that match
	//    the bug's failure association rule. This will allow us to adjust the
	//    bug's priority and close or reopen it (if needed).
	// - Source (Suggested) Clusters: for newly filed bugs, analysis on
	//    failures matching the the failure association rule may not be
	//    ready or complete yet. We bridge  this time period by relying
	//    on the impact of the suggested cluster the bug was automatically
	//    filed for (if any).
	// - Impactful Suggested Clusters: if any suggested clusters have
	//    reached the threshold to file a new bug for, we want to read
	//    them, so we can file a bug.
	clusterSummaries, err := b.clusterClient.ReadImpactfulClusters(ctx, analysis.ImpactfulClusterReadOptions{
		Project:                  b.project,
		Thresholds:               b.bugFilingThreshold,
		AlwaysIncludeBugClusters: true,
	})
	if err != nil {
		return errors.Annotate(err, "read impactful clusters").Err()
	}
	ruleIDBySourceClusterID := make(map[string]string)
	for _, r := range ruleByID {
		ruleIDBySourceClusterID[r.SourceCluster.Key()] = r.RuleID
	}

	var toCreateBugsFor []*analysis.ClusterSummary
	impactByRuleID := make(map[string]*bugs.ClusterImpact)
	for _, clusterSummary := range clusterSummaries {
		if clusterSummary.ClusterID.IsBugCluster() {
			// Never create further bugs for bug clusters.
			continue
		}

		// Was a bug filed for this source cluster?
		// We want to avoid race conditions whereby we file multiple bug
		// clusters for the same source cluster, because re-clustering and
		// re-analysis has not yet run and moved residual impact from the
		// source (suggested) cluster to the bug cluster.
		// (Of course, if a bug cluster was filed for a source cluster,
		// but the bug cluster's failure association rule was subsequently
		// modified (e.g. narrowed), it is allowed to file another bug
		// if the residual impact justifies it.)
		//
		// TODO(crbug.com/1243174): Only prevent a new bug cluster being
		// filed for a sugested cluster until a full re-clustering and
		// analysis pass has finished.
		ruleID, ok := ruleIDBySourceClusterID[clusterSummary.ClusterID.Key()]
		if ok {
			// Currently re-clustering is not implemented, so we
			// must derive the bug's impact from the source cluster.
			impactByRuleID[ruleID] = bugs.ExtractResidualImpact(clusterSummary)
			// Do not file a bug.
			continue
		}

		// Only file a bug if the residual impact exceeds the threshold.
		impact := bugs.ExtractResidualImpact(clusterSummary)
		if !impact.MeetsThreshold(b.bugFilingThreshold) {
			continue
		}

		toCreateBugsFor = append(toCreateBugsFor, clusterSummary)
	}

	bugsFiled := 0
	for _, clusterSummary := range toCreateBugsFor {
		// Throttle how many bugs may be filed each time.
		if bugsFiled >= b.MaxBugsFiledPerRun {
			break
		}
		created, err := b.createBug(ctx, clusterSummary)
		if err != nil {
			return err
		}
		if created {
			bugsFiled++
		}
	}

	// Iterate over all active bug clusters (except those we just created).
	bugUpdatesBySystem := make(map[string][]*bugs.BugToUpdate)
	for id, r := range ruleByID {
		// TODO(crbug.com/1243174): Once re-clustering is implemented,
		// pause bug updates between when a rule is created or updated
		// and when re-clustering has completed again. This will avoid
		// bugs getting erroneous priority changes while impact information
		// is incomplete.
		impact, ok := impactByRuleID[id]
		if !ok {
			// If there is no analysis, this usually means the cluster is
			// empty, so we should use empty impact.
			impact = &bugs.ClusterImpact{}
		}

		system, bug, err := toSystemBugName(r.Bug)
		if err != nil {
			logging.Warningf(ctx, "Failure association rule %s/%s has an invalid bug: %q", b.project, r.RuleID, r.Bug)
			continue
		}
		bugUpdates := bugUpdatesBySystem[system]
		bugUpdates = append(bugUpdates, &bugs.BugToUpdate{
			BugName: bug,
			Impact:  impact,
		})
		bugUpdatesBySystem[system] = bugUpdates
	}

	for system, bugsToUpdate := range bugUpdatesBySystem {
		manager, ok := b.managers[system]
		if !ok {
			logging.Warningf(ctx, "Encountered bug(s) with an unrecognised manager: %q", manager)
			continue
		}
		if err := manager.Update(ctx, bugsToUpdate); err != nil {
			return err
		}
	}
	return nil
}

// createBug files a new bug for the given suggested cluster,
// and stores the association from bug to failures through a new
// failure association rule.
func (b *BugUpdater) createBug(ctx context.Context, cs *analysis.ClusterSummary) (created bool, err error) {
	ruleID, err := generateRuleID()
	if err != nil {
		return false, errors.Annotate(err, "generating rule ID").Err()
	}

	failure := &clustering.Failure{
		TestID: cs.ExampleTestID,
	}
	if cs.ExampleFailureReason.Valid {
		failure.Reason = cs.ExampleFailureReason.StringVal
	}

	alg, err := algorithms.ByName(cs.ClusterID.Algorithm)
	if err == algorithms.ErrAlgorithmNotExist {
		// The cluster is for an old algorithm that no longer exists, or
		// for a new algorithm that is not known by us yet.
		// Do not file a bug. This is not an error, it is expected during
		// algorithm version changes.
		return false, nil
	}
	if hex.EncodeToString(alg.Cluster(failure)) != cs.ClusterID.ID {
		// Double-check the failure matches the cluster. Generating a
		// failure association rule that does not match the suggested cluster
		// could result in indefinite creation of new bugs, as the system
		// will repeatedly file a new failure association rule for the
		// same suggested cluster.
		return false, errors.New("example failure did not match cluster ID")
	}
	rule := alg.FailureAssociationRule(failure)
	cluster := &bugs.Cluster{
		DisplayName: alg.ClusterDisplayName(failure),
		Description: alg.BugDescription(failure),
		Impact:      bugs.ExtractResidualImpact(cs),
	}

	// For now, the only issue system supported is monorail.
	system := monorail.ManagerName
	mgr := b.managers[system]
	name, err := mgr.Create(ctx, cluster)

	bug, err := fromSystemBugName(system, name)
	if err != nil {
		return false, errors.Annotate(err, "constructing bug name").Err()
	}
	if err == bugs.ErrCreateSimulated {
		// Create did not do anything because it is in simulation mode.
		// This is expected.
		return false, nil
	}
	if err != nil {
		return false, errors.Annotate(err, "create issue in %v", mgr).Err()
	}

	// Create a bug cluster entry linking the cluster with the bug.
	r := &FailureAssociationRule{
		Project:        b.project,
		RuleID:         ruleID,
		RuleDefinition: rule,
		Bug:            bug,
		IsActive:       true,
		SourceCluster:  cs.ClusterID,
	}
	create := func(ctx context.Context) error {
		return Create(ctx, r)
	}
	if _, err := span.ReadWriteTransaction(ctx, create); err != nil {
		return false, errors.Annotate(err, "create bug cluster").Err()
	}
	return true, nil
}

// generateRuleID returns a random 128-bit rule ID, encoded as
// 32 lowercase hexadecimal characters.
func generateRuleID() (string, error) {
	randomBytes := make([]byte, 16)
	_, err := rand.Read(randomBytes)
	if err != nil {
		return "", err
	}
	return hex.EncodeToString(randomBytes), nil
}

func (b *BugUpdater) readActiveFailureAssociationRules(ctx context.Context) (map[string]*FailureAssociationRule, error) {
	rs, err := ReadActive(span.Single(ctx), b.project)
	if err != nil {
		return nil, err
	}

	ruleByID := make(map[string]*FailureAssociationRule)
	for _, r := range rs {
		ruleByID[r.RuleID] = r
	}
	return ruleByID, nil
}

// clusterKey returns the key used for clusters in dictionaries.
func clusterKey(clusterAlgorithm string, clusterID string) string {
	return fmt.Sprintf("%q/%q", clusterAlgorithm, clusterID)
}

// toSystemBugName splits a Weetbix bug identifier like
// "monorail/{monorail_project}/{numeric_id}" into its system (monorail)
// and bug name ({monorail_project}/{numeric_id}) components.
func toSystemBugName(bug string) (system string, name string, err error) {
	parts := bugRe.FindStringSubmatch(bug)
	if parts == nil {
		return "", "", fmt.Errorf("invalid bug %q", bug)
	}
	return parts[1], parts[2], nil
}

// fromSystemBugName converts a system bug name to a Weetbix bug identifier,
// by namespacing the bug name with its system name.
func fromSystemBugName(system string, name string) (string, error) {
	if system == "" {
		return "", errors.New("system must not be empty")
	}
	if name == "" {
		return "", errors.New("name must not be empty")
	}
	return fmt.Sprintf("%s/%s", system, name), nil
}
