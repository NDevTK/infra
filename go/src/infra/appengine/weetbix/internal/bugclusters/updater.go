// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package bugclusters

import (
	"context"
	"fmt"
	"regexp"

	"infra/appengine/weetbix/internal/bugs"
	"infra/appengine/weetbix/internal/bugs/monorail"
	"infra/appengine/weetbix/internal/clustering"
	"infra/appengine/weetbix/internal/config"

	"go.chromium.org/luci/common/errors"
	"go.chromium.org/luci/common/logging"
	"go.chromium.org/luci/server/span"
)

// TODO (crbug.com/1243174): Currently analysis is hardcoded to only analyse
// one LUCI project, which is recorded here.
const analysisProject = "chromium"

// bugRe matches Weetbix bug names, of the form
// "{bug_system}/{bug_id}", for example, "monorail/chromium/123", where
// bug_system = "monorail and bug_id = "chromium/123". bug_id may be further
// parsed by bug managers for particular bug systems.
var bugRe = regexp.MustCompile(`^([a-z0-9\-_]+)/(.+)$`)

// ClusterClient is an interface for accessing cluster analysis.
type ClusterClient interface {
	// ReadImpactfulClusters reads analysis for clusters matching the
	// specified criteria.
	ReadImpactfulClusters(ctx context.Context, opts clustering.ImpactfulClusterReadOptions) ([]*clustering.Cluster, error)
}

// BugManager implements bug creation and bug updates for a bug-tracking
// system. The BugManager determines bug content and priority given a
// cluster.
type BugManager interface {
	// Create creates a new bug for the given cluster, returning its name,
	// or any encountered error.
	Create(ctx context.Context, cluster *clustering.Cluster) (string, error)
	// Update updates the specified list of bugs.
	Update(ctx context.Context, bugs []*bugs.BugToUpdate) error
}

// BugUpdater performs updates to Monorail bugs and BugClusters to keep them
// in sync with clusters generated by analysis.
type BugUpdater struct {
	clusterClient ClusterClient
	// managers stores the manager responsible for updating bugs for each
	// bug tracking system (monorail, buganizer, etc.).
	managers map[string]BugManager
	// bugFilingThreshold stores the per-project threshold at which bugs should be filed.
	// The map key is the project name.
	bugFilingThresholds map[string]*config.ImpactThreshold
	// MaxBugsFiledPerRun is the maximum number of bugs to file each time
	// BugUpdater runs. This throttles the rate of changes to monorail.
	MaxBugsFiledPerRun int
}

// NewBugUpdater initialises a new BugUpdater. The specified impact thresholds are used
// when determining whether to a file a bug.
func NewBugUpdater(mgrs map[string]BugManager, cc ClusterClient, bugFilingThresholds map[string]*config.ImpactThreshold) *BugUpdater {
	return &BugUpdater{
		managers:            mgrs,
		clusterClient:       cc,
		bugFilingThresholds: bugFilingThresholds,
		MaxBugsFiledPerRun:  1, // Default value.
	}
}

// Run updates bug clusters to match high-impact clusters as identified by analysis.
func (b *BugUpdater) Run(ctx context.Context) error {
	bcByAssociatedCluster, err := b.readActiveBugClusters(ctx)
	if err != nil {
		return errors.Annotate(err, "read active bug clusters").Err()
	}
	var clusterIDs []string
	for _, bcd := range bcByAssociatedCluster {
		clusterIDs = append(clusterIDs, bcd.AssociatedClusterID)
	}
	clusters, err := b.clusterClient.ReadImpactfulClusters(ctx, clustering.ImpactfulClusterReadOptions{
		Project:                 analysisProject,
		Thresholds:              b.bugFilingThresholds[analysisProject],
		AlwaysIncludeClusterIDs: clusterIDs,
	})
	if err != nil {
		return errors.Annotate(err, "read impactful clusters").Err()
	}

	var toCreateBugsFor []*clustering.Cluster
	clustersByKey := make(map[string]*clustering.Cluster)
	for _, cluster := range clusters {
		key := clusterKey(cluster.Project, cluster.ClusterID)
		clustersByKey[key] = cluster

		// Find new bugs to create.
		_, ok := bcByAssociatedCluster[key]
		if !ok {
			toCreateBugsFor = append(toCreateBugsFor, cluster)
		}
	}

	bugsFiled := 0
	for _, cluster := range toCreateBugsFor {
		// Throttle how many bugs may be filed each time.
		if bugsFiled >= b.MaxBugsFiledPerRun {
			break
		}
		if err := b.createBugCluster(ctx, cluster); err != nil {
			return err
		}
		bugsFiled++
	}

	// Iterate over all active bug clusters (except those we just created).
	bugUpdatesBySystem := make(map[string][]*bugs.BugToUpdate)
	for key, bc := range bcByAssociatedCluster {
		// Find corresponding cluster.
		cluster, ok := clustersByKey[key]
		if !ok {
			// Cluster no longer exists, create an empty (imapctless)
			// cluster instead.
			cluster = &clustering.Cluster{
				Project:   bc.Project,
				ClusterID: bc.AssociatedClusterID,
			}
		}

		system, bug, err := toSystemBugName(bc.Bug)
		if err != nil {
			logging.Warningf(ctx, "Encountered a bug cluster with an invalid bug: %q", bc.Bug)
			continue
		}
		bugUpdates := bugUpdatesBySystem[system]
		bugUpdates = append(bugUpdates, &bugs.BugToUpdate{
			BugName: bug,
			Cluster: cluster,
		})
		bugUpdatesBySystem[system] = bugUpdates
	}

	for system, bugsToUpdate := range bugUpdatesBySystem {
		manager, ok := b.managers[system]
		if !ok {
			logging.Warningf(ctx, "Encountered bug(s) with an unrecognised manager: %q", manager)
			continue
		}
		if err := manager.Update(ctx, bugsToUpdate); err != nil {
			return err
		}
	}
	return nil
}

// createBugCluster files a new bug for the given analysis cluster,
// and stores the association from analysis cluster to bug in the bug
// clusters table.
func (b *BugUpdater) createBugCluster(ctx context.Context, cluster *clustering.Cluster) error {
	// For now, the only issue system supported is monorail.
	system := monorail.ManagerName
	mgr := b.managers[system]
	name, err := mgr.Create(ctx, cluster)

	if err == bugs.ErrCreateSimulated {
		// Create did not do anything because it is in simulation mode.
		// This is expected.
		return nil
	}
	if err != nil {
		return errors.Annotate(err, "create issue in %v", mgr).Err()
	}
	bug, err := fromSystemBugName(system, name)
	if err != nil {
		return errors.Annotate(err, "constructing bug name").Err()
	}

	// Create a bug cluster entry linking the cluster with the bug.
	bc := &BugCluster{
		Project:             cluster.Project,
		Bug:                 bug,
		AssociatedClusterID: cluster.ClusterID,
		IsActive:            true,
	}
	create := func(ctx context.Context) error {
		return Create(ctx, bc)
	}
	if _, err := span.ReadWriteTransaction(ctx, create); err != nil {
		return errors.Annotate(err, "create bug cluster").Err()
	}
	return nil
}

func (b *BugUpdater) readActiveBugClusters(ctx context.Context) (map[string]*BugCluster, error) {
	bcs, err := ReadActiveForAllProjects(span.Single(ctx))
	if err != nil {
		return nil, err
	}

	bcByAssociatedCluster := make(map[string]*BugCluster)
	for _, bc := range bcs {
		key := clusterKey(bc.Project, bc.AssociatedClusterID)
		bcByAssociatedCluster[key] = bc
	}
	return bcByAssociatedCluster, nil
}

// clusterKey returns the key used for clusters in dictionaries. The cluster
// ID is namespaced within the LUCI project for which Weetbix is performing
// analysis.
func clusterKey(project string, clusterID string) string {
	return fmt.Sprintf("%q/%q", project, clusterID)
}

// toSystemBugName splits a Weetbix bug identifier like
// "monorail/{monorail_project}/{numeric_id}" into its system (monorail)
// and bug name ({monorail_project}/{numeric_id}) components.
func toSystemBugName(bug string) (system string, name string, err error) {
	parts := bugRe.FindStringSubmatch(bug)
	if parts == nil {
		return "", "", fmt.Errorf("invalid bug %q", bug)
	}
	return parts[1], parts[2], nil
}

// fromSystemBugName converts a system bug name to a Weetbix bug identifier,
// by namespacing the bug name with its system name.
func fromSystemBugName(system string, name string) (string, error) {
	if system == "" {
		return "", errors.New("system must not be empty")
	}
	if name == "" {
		return "", errors.New("name must not be empty")
	}
	return fmt.Sprintf("%s/%s", system, name), nil
}
