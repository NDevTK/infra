// Copyright 2022 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto3";

package weetbix.v1;

option go_package = "infra/appengine/weetbix/proto/v1;weetbixpb";

import "google/protobuf/timestamp.proto";
import "infra/appengine/weetbix/proto/v1/common.proto";
import "infra/appengine/weetbix/proto/v1/failure_reason.proto";

// Provides methods to cluster test results, and obtain the impact of those
// clusters.
//
// A cluster is a group of test failures with a common characteristic.
// For example, test results may form a cluster with other failures that share
// a common test name, or failure reason. Test results may also be in a cluster
// defined by a user-modifiable failure association rule (which associates
// failures with a bug). In this case, the failures have the property defined
// by the failure association rule in common.
//
// A test result may be in many clusters, and each cluster may contain many
// test results.
//
// Each cluster has an identity, consisting of three components:
// - The LUCI Project name, e.g. "chromium" or "fuchsia".
// - The Clustering Algorithm that identified the cluster. As at writing
//   (April 2022), the algorithms are 'testname-v3' for version 3 of the
//   test-name clustering algorithm, 'reason-v3' for version 3 of the failure
//   reason clustering algorithm, and 'rules-v2' for the rules-based clustering
//   algorithm.
//   (Although internally versioned, the rules algorithm version is hidden
//   for clients, so that {luci_project}/rules/{rule_id} always represents
//   the cluster defined by the given rule_id.)
//   We make no guarantees about the structure of algorithm names, they should
//   be treated as opaque strings by clients.
// - An algorithm-defined cluster identifier. This is algorithm-dependent and
//   although (as at April 2022) a lowercase hexadecimal string, should be
//   treated as an opaque value by clients.
//   For the 'rules' algorithm, the cluster identifier will always correspond
//   to the Rule ID of the rule that defines the cluster.
service Clusters {
    // Identifies the cluster(s) for one or more test failure(s).
    //
    // This RPC returns the clusters of each test result, using
    // current suggested cluster algorithms, configured failure
    // association rules, and ingested project configuration with
    // a bounded staleness of up to one minute. (Returned clusters
    // may be based on project configuration and configured failure
    // association rules that is up to one minute out-of-date).
    //
    // As at April 2022, the implementation does not use stale
    // rules, but you are instructed NOT to rely on this property to
    // allow reversion to the faster implementation that is tolerant
    // to higher QPS in future. If your use case require strong reads
    // (e.g. you want to call cluster immediately after updating a rule),
    // please contact Weetbix owners. We may be able to provide a
    // request flag to select this processing behaviour.
    //
    // This RPC is a pure query API and does not lead to the ingestion of the
    // test failures by Weetbix (e.g. for cluster impact calculations).
    rpc Cluster(ClusterRequest) returns (ClusterResponse) {};

    // Reads summary information about the given clusters.
    //
    // Please consult Weetbix owners before adding additional calls to this
    // RPC, as the implementation currently calls back to BigQuery and as
    // such, is not cost-optimised if many queries are to be made.
    //
    // As of writing (April 13, 2022) this query reads ~1 GB per call for
    // the largest LUCI Project, which translates to a cost of 0.5 US cents
    // per query at published pricing (US$5/TB analyzed for BigQuery).
    //
    // Changes to this RPC should comply with https://google.aip.dev/231.
    rpc BatchGet(BatchGetClustersRequest)
        returns (BatchGetClustersResponse) {};

    // Reads current progress re-clustering the given project. Re-clustering
    // means updating the clusters each failure is in to reflect the latest
    // failure association rules, suggested clustering algorithms and
    // clustering configuration.
    rpc GetReclusteringProgress(GetReclusteringProgressRequest)
        returns (ReclusteringProgress) {};
}

message ClusterRequest {
    // TestResult captures information about a test result, sufficient to
    // cluster it. The fields requested here may be expanded over time.
    // For example, variant information may be requested in future.
    message TestResult {
        // Opaque tag supplied by the caller, to be returned in the
        // response. Provided to assist correlating responses with requests.
        // Does not need to be unique. Optional.
        string request_tag = 1;

        // Identifier of the test (as reported to ResultDB).
        // For chromium projects, this starts with ninja://.
        string test_id = 2;

        // The failure reason of the test (if any).
        weetbix.v1.FailureReason failure_reason = 3;
    }
    // The LUCI Project for which the test result should be clustered.
    string project = 1;

    // The test results to cluster. At most 1000 test results may be
    // clustered in one request.
    repeated TestResult test_results = 2;
}

message ClusterResponse {
    // The cluster(s) a test result is contained in.
    message ClusteredTestResult {
       // An individual cluster a test result is contained in.
       message ClusterEntry {
          // The unique identifier of the cluster.
          // If the algorithm is "rules", the cluster ID is also a rule ID.
          weetbix.v1.ClusterId cluster_id = 1;

          // The bug associated with the cluster, if any. This is only
          // populated for clusters defined by a failure association rule,
          // which associates specified failures to a bug.
          weetbix.v1.AssociatedBug bug = 2;
       }
       // Opaque tag supplied by the caller in the request. Provided to assist
       // the caller correlate responses with requests.
       string request_tag = 1;

       // The clusters the test result is contained within.
       repeated ClusterEntry clusters = 2;
    }

   // The clusters each test result is in.
   // Contains one result for each test result specified in the request.
   // Results are provided in the same order as the request, so
   // the i-th ClusteredTestResult corresponds to the i-th
   // TestResult in the request.
   repeated ClusteredTestResult clustered_test_results = 1;

   // The versions of clustering algorithms, rules and project configuration
   // used to service this request. For debugging purposes only.
   ClusteringVersion clustering_version = 2;
}

// The versions of algorithms, rules and configuration used by Weetbix
// to cluster test results. For a given test result and ClusteringVersion,
// the set of returned clusters should always be the same.
message ClusteringVersion {
    // The version of clustering algorithms used.
    int32 algorithms_version = 1;

    // The version of failure association rules used. This is the Spanner
    // commit timestamp of the last rule modification incorporated in the
    // set of rules used to cluster the results.
    google.protobuf.Timestamp rules_version = 2;

    // The version of project configuration used. This is the timestamp
    // the project configuration was ingested by Weetbix.
    google.protobuf.Timestamp config_version = 3;
}

message BatchGetClustersRequest {
    // The LUCI project shared by all clusters to retrieve.
    // Required.
    // Format: projects/{project}.
    string parent = 1;

    // The resource name of the clusters retrieve.
    // Format: projects/{project}/clusters/{cluster_algorithm}/{cluster_id}.
    // Designed to conform to aip.dev/231.
    // At most 1,000 clusters may be requested at a time.
    repeated string names = 2;
}

message BatchGetClustersResponse {
    // The clusters requested.
    repeated Cluster clusters = 1;
}

message Cluster {
    // The resource name of the cluster.
    // Format: projects/{project}/clusters/{cluster_algorithm}/{cluster_id}.
    string name = 1;

    // Whether there is a recent example in the cluster.
    bool has_example = 2;

    // A human-readable name for the cluster.
    // Only populated for suggested clusters where has_example = true.
    // Not populated for rule-based clusters.
    string title = 3;

    message MetricValues {
        message Counts {
            // The value of the metric (summed over all failures).
            int64 nominal = 1;
        }

        // The metric value for the last day.
        Counts one_day = 2;
        // The metric value for the last three days.
        Counts three_day = 3;
        // The metric value for the last week.
        Counts seven_day = 4;
    }

    // The total number of user changelists which failed presubmit.
    MetricValues user_cls_failed_presubmit = 4;

    // The total number of failures in the cluster that occurred on tryjobs
    // that were critical (presubmit-blocking) and were exonerated for a
    // reason other than NOT_CRITICAL or UNEXPECTED_PASS.
    MetricValues critical_failures_exonerated = 5;

    // The total number of failures in the cluster.
    MetricValues failures = 6;

    // The failure association rule equivalent to the cluster. Populated only
    // for suggested clusters where has_example = true.
    // Not populated for rule-based clusters. If you need the failure
    // association rule for a rule-based cluster, use weetbix.v1.Rules/Get
    // to retrieve the rule with ID matching the cluster ID.
    // Used to facilitate creating a new rule based on a suggested cluster.
    string equivalent_failure_association_rule = 7;
}

// Designed to conform with aip.dev/131.
message GetReclusteringProgressRequest {
    // The name of the reclustering progress resource to retrieve.
    // Format: projects/{project}/reclusteringProgress.
    string name = 1;
}

// ReclusteringProgress captures the progress re-clustering a
// given LUCI project's test results using specific rules
// versions or algorithms versions.
message ReclusteringProgress {
    // The name of the reclustering progress resource.
    // Format: projects/{project}/reclusteringProgress.
    string name = 1;
    // ProgressPerMille is the progress of the current re-clustering run,
    // measured in thousandths (per mille). As such, this value ranges
    // from 0 (0% complete) to 1000 (100% complete).
    int32 progress_per_mille = 2;
    // The goal of the last completed re-clustering run.
    ClusteringVersion last = 5;
    // The goal of the current re-clustering run. (For which
    // ProgressPerMille is specified.) This may be the same as the
    // last completed re-clustering run the available algorithm versions,
    // rules and configuration is unchanged.
    ClusteringVersion next = 6;
}
