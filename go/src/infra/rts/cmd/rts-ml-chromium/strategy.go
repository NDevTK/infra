// Copyright 2022 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package main

import (
	"context"
	"fmt"
	"math"
	"path"
	"regexp"
	"strings"

	"go.chromium.org/luci/common/errors"
	"go.chromium.org/luci/common/logging"

	"infra/rts"
	"infra/rts/filegraph/git"
	"infra/rts/presubmit/eval"
	evalpb "infra/rts/presubmit/eval/proto"
)

// mustAlwaysRunTest returns true if the test file must never be skipped.
func mustAlwaysRunTest(testFile string) bool {
	switch {
	// Always run all third-party tests (never skip them),
	// except //third_party/blink which is actually first party.
	case strings.Contains(testFile, "/third_party/") && !strings.HasPrefix(testFile, "//third_party/blink/"):
		return true

	case testFile == "//third_party/blink/web_tests/wpt_internal/webgpu/cts.html":
		// Most of cts.html commits are auto-generated.
		// https://source.chromium.org/chromium/chromium/src/+/HEAD:third_party/blink/web_tests/wpt_internal/webgpu/cts.html;l=5;bpv=1;bpt=0
		// cts.html does not have meaningful edges in the file graph.
		return true

	default:
		return false
	}
}

var (
	// requireAllTests is a list of patterns of files that require running all
	// tests.
	requireAllTests = []string{
		// A CL changes the way tests run or their configurations.
		"//testing/.+",

		// The full list of modified files is not available, and the
		// graph does not include DEPSed file changes anyway.
		"//DEPS",

		// MB CLs change the way tests run or their configurations.
		"//tools/mb/.+",
	}
	requireAllTestsRegexp = regexp.MustCompile(fmt.Sprintf("^(%s)$", strings.Join(requireAllTests, "|")))

	disableRTS = errors.BoolTag{Key: errors.NewTagKey("skip RTS")}
)

func (r *createModelRun) evalStrategy() eval.Strategy {
	onTestNotFound := func(ctx context.Context, tv *evalpb.TestVariant) {
		if strings.Contains(path.Base(tv.FileName), "autogen") {
			// This file is autogenerated.
			return
		}
		logging.Warningf(ctx, "test file not found: %s", tv.FileName)
	}
	gitStrategy := &git.SelectionStrategy{
		Graph: r.fg,
		EdgeReader: &git.EdgeReader{
			ChangeLogDistanceFactor:     1,
			FileStructureDistanceFactor: 0,
		},
		OnTestNotFound: onTestNotFound,
	}
	fileStrategy := &git.SelectionStrategy{
		Graph: r.fg,
		EdgeReader: &git.EdgeReader{
			ChangeLogDistanceFactor:     0,
			FileStructureDistanceFactor: 1,
		},
		OnTestNotFound: onTestNotFound,
	}

	return func(ctx context.Context, in eval.Input, out *eval.Output) error {
		for _, f := range in.ChangedFiles {
			switch {
			case f.Repo != "https://chromium.googlesource.com/chromium/src":
				return errors.Reason("unexpected repo %q", f.Repo).Err()
			case requireAllTestsRegexp.MatchString(f.Path):
				return nil
			}
		}

		// Get the git based distance
		if err := gitStrategy.SelectEval(ctx, in, out); err != nil {
			return err
		}
		gitDistances := make([]float64, len(in.TestVariants))
		for i := 0; i < len(gitDistances); i++ {
			gitDistances[i] = out.TestVariantAffectedness[i].Distance
		}

		// Get the file based distance
		if err := fileStrategy.SelectEval(ctx, in, out); err != nil {
			return err
		}
		fileDistances := make([]float64, len(in.TestVariants))
		for i := 0; i < len(fileDistances); i++ {
			fileDistances[i] = out.TestVariantAffectedness[i].Distance
		}

		// Create the examples to be inferred, using the appropriate day
		var examples = make([]mlExample, len(in.TestVariants))
		for i := range in.TestVariants {

			example, ok := r.stabilityMap[stabilityMapKey{testID: in.TestVariants[i].Id, date: in.Timestamp}]
			if !ok {
				example = mlExample{}
				logging.Warningf(ctx, "Stability info not found: %s for %s", in.TestVariants[i].Id, in.Timestamp)
			}
			example.GitDistance = gitDistances[i]
			example.UseGitDistance = gitDistances[i] != 0.0 && !math.IsInf(gitDistances[i], 0)
			example.FileDistance = fileDistances[i]
			example.UseFileDistance = fileDistances[i] != 0.0 && !math.IsInf(fileDistances[i], 0)
			examples[i] = example
		}

		predictions, err := fileInferMlModel(examples, r.mlModelDir, r.cli)

		if err != nil {
			return err
		}

		for i := range out.TestVariantAffectedness {
			out.TestVariantAffectedness[i] = rts.Affectedness{Distance: predictions[i]}
		}

		// No matter what filegraph said, never skip certain tests.
		for i, tv := range in.TestVariants {
			if mustAlwaysRunTest(tv.FileName) {
				out.TestVariantAffectedness[i] = rts.Affectedness{Distance: 0}
			}
		}
		return nil
	}
}
