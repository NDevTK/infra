// Copyright 2022 The ChromiumOS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package dumper

import (
	"context"
	"fmt"
	"reflect"
	"time"

	"github.com/golang/protobuf/proto"
	"go.chromium.org/luci/common/errors"
	"go.chromium.org/luci/common/logging"

	iv2api "infra/appengine/cros/lab_inventory/api/v1"
	"infra/cros/hwid"
	ufspb "infra/unifiedfleet/api/v1/models"
	ufsmfgcfg "infra/unifiedfleet/api/v1/models/chromeos/manufacturing"
	"infra/unifiedfleet/app/config"
	"infra/unifiedfleet/app/controller"
	"infra/unifiedfleet/app/external"
	"infra/unifiedfleet/app/model/configuration"
	"infra/unifiedfleet/app/model/registration"
	"infra/unifiedfleet/app/util"
)

// manufacturingConfigDiffHandler compares the ManufacturingConfig fetched from
// Inventory V2 with the ManufacturingConfig generated by parsing HwidData
// stored in UFS.
func manufacturingConfigDiffHandler(ctx context.Context) error {
	ctx = setupMfgcfgDiffContext(ctx)

	// File writer setup
	filename := fmt.Sprintf("mfgcfg_diff/%s.log", time.Now().UTC().Format("2006-01-02T03:04:05"))
	writer, err := getCloudStorageWriter(ctx, filename)
	if err != nil {
		return err
	}
	defer func() {
		if writer != nil {
			if err := writer.Close(); err != nil {
				logging.Warningf(ctx, "failed to close cloud storage writer: %s", err)
			}
		}
	}()

	invV2Client, err := getInventoryV2Client(ctx)
	if err != nil {
		return err
	}

	machines, err := registration.ListAllMachines(ctx, false)
	if err != nil {
		return err
	}
	if machines == nil {
		return errors.New("machine lse entities are missing")
	}

	for _, machine := range machines {
		hwid := machine.GetChromeosMachine().GetHwid()
		if hwid == "" {
			continue
		}

		// Inv V2 implementation
		mfgCfgInvV2, err := getManufacturingConfigFromInvV2(ctx, invV2Client, hwid)
		if err != nil {
			logging.Warningf(ctx, "InvV2 ManufacturingConfig for %s not found. Error: %s", hwid, err)
		}

		// UFS implementation
		hwidData, err := getHwidData(ctx, hwid)
		if err != nil {
			logging.Warningf(ctx, "Hwid data for %s not found. Error: %s", hwid, err)
		}

		var mfgCfgUFS *ufsmfgcfg.ManufacturingConfig
		if !reflect.ValueOf(hwidData).IsNil() {
			mfgCfgUFS, err = getManufacturingConfigFromUFS(ctx, hwidData)
			if err != nil {
				logging.Warningf(ctx, "UFS ManufacturingConfig for %s not found. Error: %s", hwid, err)
			}
		}

		// Log information on diff if exists
		if !proto.Equal(mfgCfgInvV2, mfgCfgUFS) {
			logMsg := fmt.Sprintf("%s %s", machine.GetName(), hwid)
			if _, err := fmt.Fprint(writer, logMsg); err != nil {
				return err
			}
		}
	}

	return nil
}

func setupMfgcfgDiffContext(ctx context.Context) context.Context {
	ctx = logging.SetLevel(ctx, logging.Warning)
	ctx, _ = util.SetupDatastoreNamespace(ctx, util.OSNamespace)
	return ctx
}

// The below methods are implementations copy and pasted from dut.go

func getInventoryV2Client(ctx context.Context) (external.CrosInventoryClient, error) {
	es, err := external.GetServerInterface(ctx)
	if err != nil {
		return nil, err
	}
	return es.NewCrosInventoryInterfaceFactory(ctx, config.Get(ctx).GetCrosInventoryHost())
}

func getHwidClient(ctx context.Context) (hwid.ClientInterface, error) {
	es, err := external.GetServerInterface(ctx)
	if err != nil {
		return nil, err
	}
	return es.NewHwidClientInterface(ctx)
}

func getHwidData(ctx context.Context, hwid string) (*ufspb.HwidData, error) {
	hwidClient, err := getHwidClient(ctx)
	if err != nil {
		logging.Errorf(ctx, "Failed to get HwidClient. Error: %s", err)
		return nil, err
	}

	d, err := controller.GetHwidData(ctx, hwidClient, hwid)
	if err != nil {
		return nil, err
	}
	return d, nil
}

func getManufacturingConfigFromInvV2(ctx context.Context, inv2Client external.CrosInventoryClient, id string) (*ufsmfgcfg.ManufacturingConfig, error) {
	resp, err := inv2Client.GetManufacturingConfig(ctx, &iv2api.GetManufacturingConfigRequest{
		Name: id,
	})
	if err != nil {
		return nil, err
	}
	s := proto.MarshalTextString(resp)
	var mfgConfig ufsmfgcfg.ManufacturingConfig
	proto.UnmarshalText(s, &mfgConfig)
	return &mfgConfig, err
}

func getManufacturingConfigFromUFS(ctx context.Context, hwidData *ufspb.HwidData) (*ufsmfgcfg.ManufacturingConfig, error) {
	return configuration.ParseHwidDataIntoMfgCfg(hwidData)
}
