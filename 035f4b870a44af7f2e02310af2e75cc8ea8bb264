{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "db064483_f4ffd77b",
        "filename": "go/src/infra/experimental/golangbuild/testmode.go",
        "patchSetId": 2
      },
      "lineNbr": 449,
      "author": {
        "id": 1154295
      },
      "writtenOn": "2023-09-14T18:40:44Z",
      "side": 1,
      "message": "this is clever. :) but I think in the particular case of misccompile it would be reasonable to do some kind of simpler manual sharding. (e.g. divide the list into N groups of ports all of approximately the same size)\n\neach port compilation is approximately the same (so we\u0027re sharding homogeneous bits of work) and we add ports pretty rarely compared to tests or even packages.",
      "range": {
        "startLine": 448,
        "startChar": 0,
        "endLine": 449,
        "endChar": 195
      },
      "revId": "035f4b870a44af7f2e02310af2e75cc8ea8bb264",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e66109c9_12f9ee4e",
        "filename": "go/src/infra/experimental/golangbuild/testmode.go",
        "patchSetId": 2
      },
      "lineNbr": 449,
      "author": {
        "id": 1568167
      },
      "writtenOn": "2023-09-14T18:53:26Z",
      "side": 1,
      "message": "I wanted to try a programmatic \"find a salt\" approach with the intention of possibly extending it to real tests that are poorly sharded. Misc-compile was a very simple place to start, since the evaluation function is very fast (just count number of shards selected and make sure it\u0027s not higher than the goal). But also it seems short code-wise: only +6 -1 diff in non-test code.\n\nI\u0027ll likely need to do this again for nShards \u003d 4 or some TBD value for sharding misc-compile in x/ repos. With this approach, it\u0027d take me a minute to run the test to find another salt for whatever that N is, and add one line to the map.\n\nI don\u0027t immediately see how manual sharding would be simpler while maintaining the property that cmd/dist execution doesn\u0027t happen in the trusted coordinator mode, only in the test modes, but maybe I\u0027m overlooking something. Do you mean adding a hard-coded list of known ports, and bucket assignments, or something else? (That seems quite verbose and not simpler, but again, maybe I\u0027m misunderstanding the suggestion.)",
      "parentUuid": "db064483_f4ffd77b",
      "range": {
        "startLine": 448,
        "startChar": 0,
        "endLine": 449,
        "endChar": 195
      },
      "revId": "035f4b870a44af7f2e02310af2e75cc8ea8bb264",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "afc8c965_0ea95753",
        "filename": "go/src/infra/experimental/golangbuild/testmode.go",
        "patchSetId": 2
      },
      "lineNbr": 449,
      "author": {
        "id": 1154295
      },
      "writtenOn": "2023-09-14T19:11:09Z",
      "side": 1,
      "message": "\u003e I don\u0027t immediately see how manual sharding would be simpler while maintaining the property that cmd/dist execution doesn\u0027t happen in the trusted coordinator mode,\n\nthe diff I have in mind is roughly:\n- add the following after L438\n```\nbucketSize :\u003d len(ports) / shard.nShards\nbucketIdx :\u003d bucketSize * shard.shardID\nports \u003d ports[bucketIdx:min(bucketIdx+bucketSize, len(ports))]\n```\n- delete L434-L436\n\nthat\u0027s a policy that\u0027s portable across test mode shards without requiring any additional coordination. it does mean that if we add new ports that the bucket assignments will shift, but my point is that I\u0027m not really worried about that since building any particular port is very similar to building any other port. the upside is that you always get a good distribution across shards.\n\nunless I\u0027m missing something, I think that would work and I think it\u0027s maybe a little simpler to understand?",
      "parentUuid": "e66109c9_12f9ee4e",
      "range": {
        "startLine": 448,
        "startChar": 0,
        "endLine": 449,
        "endChar": 195
      },
      "revId": "035f4b870a44af7f2e02310af2e75cc8ea8bb264",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ad8649a5_b956d8d1",
        "filename": "go/src/infra/experimental/golangbuild/testmode.go",
        "patchSetId": 2
      },
      "lineNbr": 449,
      "author": {
        "id": 1568167
      },
      "writtenOn": "2023-09-14T21:26:16Z",
      "side": 1,
      "message": "Thanks for clarifyingâ€”I see what you meant earlier now (it\u0027s so obvious in hindsight ðŸ˜…; so it goes).\n\nThat\u0027s definitely much simpler for splitting up dist list output across N shards. I\u0027ve switched to that. If the programmatic \"find a salt\" approach happens to be worth digging up in the future for something else, I can get it out of the earlier patch set of this CL.\n\nPTAL.",
      "parentUuid": "afc8c965_0ea95753",
      "range": {
        "startLine": 448,
        "startChar": 0,
        "endLine": 449,
        "endChar": 195
      },
      "revId": "035f4b870a44af7f2e02310af2e75cc8ea8bb264",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}