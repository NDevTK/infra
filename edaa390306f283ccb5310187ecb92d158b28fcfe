{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "cbba14a3_3c5836ed",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002539
      },
      "writtenOn": "2022-01-11T22:22:43Z",
      "side": 1,
      "message": "Is this code still used at all? ScheduleBuild and UpdateBuild are both in Go now. It is odd the token is still generated by the python code.\n\nIf you want to extract build_id from the token *exclusively* from the backend code, this approach is fine. But extracting it from client-side code (like bbagent) will be less ideal, since I don\u0027t want the token format to be part of the public API of the service. It is not a good format (it was invented long time ago before I knew better).",
      "revId": "edaa390306f283ccb5310187ecb92d158b28fcfe",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "716a34f6_39e951e9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1001907
      },
      "writtenOn": "2022-01-11T22:31:05Z",
      "side": 1,
      "message": "\"Is this code still used at all?\" This is a good question; Unfortunately there are some codepaths where you can hit v2 code in python via the v1 APIs. I know we closed two such uses last quarter, but I\u0027m not sure if all uses are dead now. If they are then I think we can do some large-scale deletion here, but it\u0027ll be a bit of yarn pull.\n\nThe original patchset here changed the token format to be \"$build_id/$build_token\" (so that bbagent could extract this). I suggested using the embedding mechanism instead, but if it\u0027s sketchy, then we could go back to the original approach that Chan had",
      "parentUuid": "cbba14a3_3c5836ed",
      "revId": "edaa390306f283ccb5310187ecb92d158b28fcfe",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f070af97_c01bf190",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002539
      },
      "writtenOn": "2022-01-11T22:34:31Z",
      "side": 1,
      "message": "Another approach is to change the build token format to something more standard and transparent like a JWT. Current tokens are semantically JWTs, just structured differently (because I didn\u0027t now about JWTs at the time).",
      "parentUuid": "716a34f6_39e951e9",
      "revId": "edaa390306f283ccb5310187ecb92d158b28fcfe",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bc0bcef6_0177ab5d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1157909
      },
      "writtenOn": "2022-01-11T22:35:37Z",
      "side": 1,
      "message": "From what I got from code search, the build token is only generated by py code, when creating the swarming task[1].\n\n[1]: https://source.chromium.org/chromium/infra/infra/+/main:appengine/cr-buildbucket/swarming.py;l\u003d581;drc\u003dc843725df4f9cd5e1e9aa3b90cb24e62bbf09e1b",
      "parentUuid": "716a34f6_39e951e9",
      "revId": "edaa390306f283ccb5310187ecb92d158b28fcfe",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0a7e3bda_55daf0a4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1157909
      },
      "writtenOn": "2022-01-11T23:08:58Z",
      "side": 1,
      "message": "About JWTs, is there a library (in both py and go) to use for generating/validating JWTs?",
      "parentUuid": "bc0bcef6_0177ab5d",
      "revId": "edaa390306f283ccb5310187ecb92d158b28fcfe",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0b4c981d_0e649b90",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002539
      },
      "writtenOn": "2022-01-11T23:30:21Z",
      "side": 1,
      "message": "Yes, though I found in practice it is usually more transparent not to use them. Generating/parsing JWTs is relatively trivial.\n\nThinking more about this issue:\n1. The build token is currently actually not interpreted by the backend at all, it is just used as a \"password\" string (go [1], python doesn\u0027t validate it at all [2]).\n2. It means we can put whatever mumbo-jumbo we want into it as long as it is random/non-guessable. We also don\u0027t need to worry about backward compatibility of the format.\n3. I kind of like that... I\u0027m asking once again, will the bbagent code try to interpret the token? If not, we can keep using some \"undisclosed\" format understood only by the backend. It doesn\u0027t have to be JWT. It doesn\u0027t have to be auth.TokenKind either. It can be something trivial as a base64-encoded serialized protobuf message with a random string somewhere inside of it, perhaps obfuscated in some trivial way to discourage deserializing it from clients. This would allow us to easily add/remove stuff there later, if necessary (using protos backward/forward compatibility).\n\n[1]: https://source.chromium.org/chromium/infra/infra/+/main:go/src/go.chromium.org/luci/buildbucket/appengine/rpc/common.go;l\u003d299?q\u003d%22func%20validateBuildToken%22\u0026ss\u003dchromium\n[2]: https://source.chromium.org/search?q\u003dvalidate_build_token\u0026sq\u003d\u0026ss\u003dchromium",
      "parentUuid": "0a7e3bda_55daf0a4",
      "revId": "edaa390306f283ccb5310187ecb92d158b28fcfe",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}