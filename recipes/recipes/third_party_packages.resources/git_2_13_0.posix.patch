From c241857ef2519b1a1d81dc0b60ddc39f596e6266 Mon Sep 17 00:00:00 2001
From: Dan Jacques <dnj@google.com>
Date: Wed, 24 May 2017 19:16:59 -0700
Subject: [PATCH] Add binary-relative lookup.

Add the ability for Git to resolve its own binary location, as well as
for it to use relative pathing against this resolution to locate
helpers and other distribution files.
---
 Makefile         |  9 +++++++
 config.mak.uname |  2 ++
 exec_cmd.c       | 32 ++++++++++++++++++++---
 exec_path.c      | 78 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 exec_path.h      |  6 +++++
 5 files changed, 123 insertions(+), 4 deletions(-)
 create mode 100644 exec_path.c
 create mode 100644 exec_path.h

diff --git a/Makefile b/Makefile
index e35542e63..933e0b527 100644
--- a/Makefile
+++ b/Makefile
@@ -758,6 +758,7 @@ LIB_OBJS += ewah/ewah_bitmap.o
 LIB_OBJS += ewah/ewah_io.o
 LIB_OBJS += ewah/ewah_rlw.o
 LIB_OBJS += exec_cmd.o
+LIB_OBJS += exec_path.o
 LIB_OBJS += fetch-pack.o
 LIB_OBJS += fsck.o
 LIB_OBJS += gettext.o
@@ -1534,6 +1535,14 @@ ifdef HAVE_GETDELIM
 	BASIC_CFLAGS += -DHAVE_GETDELIM
 endif
 
+ifdef HAVE_PROCFS
+	BASIC_CFLAGS += -DHAVE_PROCFS
+endif
+
+ifdef HAVE_NS_GET_EXECUTABLE_PATH
+	BASIC_CFLAGS += -DHAVE_NS_GET_EXECUTABLE_PATH
+endif
+
 ifeq ($(TCLTK_PATH),)
 NO_TCLTK = NoThanks
 endif
diff --git a/config.mak.uname b/config.mak.uname
index 399fe1927..7df4ab455 100644
--- a/config.mak.uname
+++ b/config.mak.uname
@@ -36,6 +36,7 @@ ifeq ($(uname_S),Linux)
 	NEEDS_LIBRT = YesPlease
 	HAVE_GETDELIM = YesPlease
 	SANE_TEXT_GREP=-a
+	HAVE_PROCFS = YesPlease
 endif
 ifeq ($(uname_S),GNU/kFreeBSD)
 	HAVE_ALLOCA_H = YesPlease
@@ -108,6 +109,7 @@ ifeq ($(uname_S),Darwin)
 	BASIC_CFLAGS += -DPRECOMPOSE_UNICODE
 	BASIC_CFLAGS += -DPROTECT_HFS_DEFAULT=1
 	HAVE_BSD_SYSCTL = YesPlease
+	HAVE_NS_GET_EXECUTABLE_PATH = YesPlease
 endif
 ifeq ($(uname_S),SunOS)
 	NEEDS_SOCKET = YesPlease
diff --git a/exec_cmd.c b/exec_cmd.c
index fb94aeba9..a128dcc74 100644
--- a/exec_cmd.c
+++ b/exec_cmd.c
@@ -1,5 +1,6 @@
 #include "cache.h"
 #include "exec_cmd.h"
+#include "exec_path.h"
 #include "quote.h"
 #include "argv-array.h"
 #define MAX_ARGS	32
@@ -40,15 +41,38 @@ char *system_path(const char *path)
 
 void git_extract_argv0_path(const char *argv0)
 {
+	char *resolved;
 	const char *slash;
 
-	if (!argv0 || !*argv0)
+	resolved = git_get_exec_path(argv0);
+	if (!resolved) {
+		trace_printf("Could not determine argv0 path from: %s\n", argv0);
 		return;
+	}
 
-	slash = find_last_dir_sep(argv0);
+	slash = find_last_dir_sep(resolved);
+	if (slash) {
+		resolved[slash - resolved] = '\0';
+	}
+	argv0_path = resolved;
+	trace_printf("Determined argv0 path from [%s]: %s\n", argv0, argv0_path);
 
-	if (slash)
-		argv0_path = xstrndup(argv0, slash - argv0);
+	/*
+	 * After calculating argv0, we want to export it to our sub-tooling so that
+	 * it is consistent. This is done automatically when it is specified via
+	 * --exec-path, but not for normal invocation.
+	 *
+	 * Our tooling (e.g., "git-remote-http") is called with a manufactured
+	 * "argv0" containing only its name, so path-relative lookup is not
+	 * functional.
+	 *
+	 * "git_set_argv_exec_path" is called after this function, so if the user
+	 * specifies an overriding path, it will still be the path that is exported.
+	 */
+	const char *exec_path = git_exec_path();
+	if (exec_path) {
+		setenv(EXEC_PATH_ENVIRONMENT, exec_path, 1);
+	}
 }
 
 void git_set_argv_exec_path(const char *exec_path)
diff --git a/exec_path.c b/exec_path.c
new file mode 100644
index 000000000..e2c30a2e8
--- /dev/null
+++ b/exec_path.c
@@ -0,0 +1,78 @@
+#include "cache.h"
+
+#ifdef HAVE_NS_GET_EXECUTABLE_PATH
+#include <mach-o/dyld.h>
+#endif
+
+static int git_get_exec_path_from_env(struct strbuf *buf)
+{
+	const char *path;
+	if ((path = getenv(EXEC_PATH_ENVIRONMENT)) != NULL) {
+		strbuf_addstr(buf, path);
+		return 0;
+	}
+	return 1;
+}
+
+static int git_get_exec_path_from_argv0(struct strbuf *buf, const char *argv0)
+{
+	const char *slash;
+
+	if (!argv0 || !*argv0) {
+		return 1;
+	}
+
+	slash = find_last_dir_sep(argv0);
+	if (slash) {
+		strbuf_add_absolute_path(buf, argv0);
+		return 0;
+	}
+	return 1;
+}
+
+#ifdef HAVE_PROCFS
+static int git_get_exec_path_procfs(struct strbuf *buf)
+{
+	char path[PATH_MAX];
+	ssize_t len;
+
+	if (realpath("/proc/self/exe", path)) {
+		strbuf_addstr(buf, path);
+		return 0;
+	}
+	return 1;
+}
+#endif
+
+
+#ifdef HAVE_NS_GET_EXECUTABLE_PATH
+static int git_get_exec_path_mac(struct strbuf *buf)
+{
+	char path[PATH_MAX];
+	uint32_t size = sizeof(path);
+	if (!_NSGetExecutablePath(path, &size)) {
+		strbuf_addstr(buf, path);
+		return 0;
+	}
+	return 1;
+}
+#endif
+
+char *git_get_exec_path(const char *argv0)
+{
+	struct strbuf buf = STRBUF_INIT;
+
+	if (
+	    !git_get_exec_path_from_env(&buf) ||
+#ifdef HAVE_PROCFS
+	    !git_get_exec_path_procfs(&buf) ||
+#endif
+#ifdef HAVE_NS_GET_EXECUTABLE_PATH
+	    !git_get_exec_path_mac(&buf) ||
+#endif
+		!git_get_exec_path_from_argv0(&buf, argv0)) {
+		return strbuf_detach(&buf, NULL);
+	}
+
+	return NULL;
+}
diff --git a/exec_path.h b/exec_path.h
new file mode 100644
index 000000000..b0afdb538
--- /dev/null
+++ b/exec_path.h
@@ -0,0 +1,6 @@
+#ifndef GIT_EXEC_PATH_H
+#define GIT_EXEC_PATH_H
+
+extern char *git_get_exec_path(const char *argv0);
+
+#endif /* GIT_EXEC_PATH_H */
-- 
2.13.0.rc1.294.g07d810a77f-goog

